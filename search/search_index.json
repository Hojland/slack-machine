{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Slack Machine Slack Machine is a simple, yet powerful and extendable Slack bot framework. More than just a bot, Slack Machine is a framework that helps you develop your Slack workspace into a ChatOps powerhouse. Slack Machine is built with an intuitive plugin system that lets you build bots quickly, but also allows for easy code organization. A plugin can look as simple as this: from machine.plugins.base import MachineBasePlugin , Message from machine.plugins.decorators import respond_to class DeploymentPlugin ( MachineBasePlugin ): \"\"\"Deployments\"\"\" @respond_to ( r \"deploy (?P<application>\\w+) to (?P<environment>\\w+)\" ) async def deploy ( self , msg : Message , application , environment ): \"\"\"deploy <application> <environment>: deploy application to target environment\"\"\" await msg . say ( f \"Deploying { application } to { environment } \" ) Note As of v0.30.0 Slack Machine dropped support for the old backend based on the RTM API. As such, Slack Machine is now fully based on AsyncIO . This means plugins written before the rewrite to asyncio aren't supported anymore. See here for a migration guide to get your old plugins working with the new version of Slack Machine. It's really easy! Features Get started with mininal configuration Built on top of the Slack Events API for smoothly responding to events in semi real-time. Uses Socket Mode so your bot doesn't need to be exposed to the internet! Support for rich interactions using the Slack Web API High-level API for maximum convenience when building plugins Low-level API for maximum flexibility Built on top of AsyncIO to ensure good performance by handling communication with Slack concurrently Plugin API features: Listen and respond to any regular expression Capture parts of messages to use as variables in your functions Respond to messages in channels, groups and direct message conversations Respond with reactions Respond in threads Respond with ephemeral messages Send DMs to any user Support for blocks Support for message attachments [Legacy \ud83c\udfda] Listen and respond to any Slack event supported by the Events API Store and retrieve any kind of data in persistent storage (currently Redis, DynamoDB and in-memory storage are supported) Schedule actions and messages Emit and listen for events Help texts for Plugins Coming Soon Support for Interactive Buttons ... and much more","title":"Slack Machine"},{"location":"#slack-machine","text":"Slack Machine is a simple, yet powerful and extendable Slack bot framework. More than just a bot, Slack Machine is a framework that helps you develop your Slack workspace into a ChatOps powerhouse. Slack Machine is built with an intuitive plugin system that lets you build bots quickly, but also allows for easy code organization. A plugin can look as simple as this: from machine.plugins.base import MachineBasePlugin , Message from machine.plugins.decorators import respond_to class DeploymentPlugin ( MachineBasePlugin ): \"\"\"Deployments\"\"\" @respond_to ( r \"deploy (?P<application>\\w+) to (?P<environment>\\w+)\" ) async def deploy ( self , msg : Message , application , environment ): \"\"\"deploy <application> <environment>: deploy application to target environment\"\"\" await msg . say ( f \"Deploying { application } to { environment } \" )","title":"Slack Machine"},{"location":"#note","text":"As of v0.30.0 Slack Machine dropped support for the old backend based on the RTM API. As such, Slack Machine is now fully based on AsyncIO . This means plugins written before the rewrite to asyncio aren't supported anymore. See here for a migration guide to get your old plugins working with the new version of Slack Machine. It's really easy!","title":"Note"},{"location":"#features","text":"Get started with mininal configuration Built on top of the Slack Events API for smoothly responding to events in semi real-time. Uses Socket Mode so your bot doesn't need to be exposed to the internet! Support for rich interactions using the Slack Web API High-level API for maximum convenience when building plugins Low-level API for maximum flexibility Built on top of AsyncIO to ensure good performance by handling communication with Slack concurrently","title":"Features"},{"location":"#plugin-api-features","text":"Listen and respond to any regular expression Capture parts of messages to use as variables in your functions Respond to messages in channels, groups and direct message conversations Respond with reactions Respond in threads Respond with ephemeral messages Send DMs to any user Support for blocks Support for message attachments [Legacy \ud83c\udfda] Listen and respond to any Slack event supported by the Events API Store and retrieve any kind of data in persistent storage (currently Redis, DynamoDB and in-memory storage are supported) Schedule actions and messages Emit and listen for events Help texts for Plugins","title":"Plugin API features:"},{"location":"#coming-soon","text":"Support for Interactive Buttons ... and much more","title":"Coming Soon"},{"location":"api/","text":"API Documentation This is the API documentation of all the classes and functions relevant for Plugin development. The rest of the code deals with the internal workings of Slack Machine and is very much an implementation detail and subject to change. Therefore it is not documented. Plugin classes The following 2 classes form the basis for Plugin development. machine.plugins.base.MachineBasePlugin Base class for all Slack Machine plugins The purpose of this class is two-fold: It acts as a marker-class so Slack Machine can recognize plugins as such It provides a lot of common functionality and convenience methods for plugins to interact with channels and users Attributes: Name Type Description settings Slack Machine settings object that contains all settings that were defined through local_settings.py Plugin developers can use any settings that are defined by the user, and ask users to add new settings specifically for their plugin. Source code in machine/plugins/base.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 class MachineBasePlugin : \"\"\"Base class for all Slack Machine plugins The purpose of this class is two-fold: 1. It acts as a marker-class so Slack Machine can recognize plugins as such 2. It provides a lot of common functionality and convenience methods for plugins to interact with channels and users :var settings: Slack Machine settings object that contains all settings that were defined through ``local_settings.py`` Plugin developers can use any settings that are defined by the user, and ask users to add new settings specifically for their plugin. \"\"\" _client : SlackClient storage : PluginStorage settings : CaseInsensitiveDict _fq_name : str def __init__ ( self , client : SlackClient , settings : CaseInsensitiveDict , storage : PluginStorage ): self . _client = client self . storage = storage self . settings = settings self . _fq_name = f \" { self . __module__ } . { self . __class__ . __name__ } \" def init ( self ) -> None : \"\"\"Initialize plugin This method can be implemented by concrete plugin classes. It will be called **once** for each plugin, when that plugin is first loaded. You can refer to settings via ``self.settings``, and access storage through ``self.storage``, but the Slack client has not been initialized yet, so you cannot send or process messages during initialization. :return: None \"\"\" pass @property def users ( self ) -> dict [ str , User ]: \"\"\"Dictionary of all users in the Slack workspace :return: a dictionary of all users in the Slack workspace, where the key is the user id and the value is a [`User`][machine.models.user.User] object \"\"\" return self . _client . users @property def channels ( self ) -> dict [ str , Channel ]: \"\"\"List of all channels in the Slack workspace This is a list of all channels in the Slack workspace that the bot is aware of. This includes all public channels, all private channels the bot is a member of and all DM channels the bot is a member of. :return: a list of all channels in the Slack workspace, where each channel is a :py:class:`~machine.models.channel.Channel` object \"\"\" return self . _client . channels @property def web_client ( self ) -> AsyncWebClient : \"\"\"Slack SDK web client to access the [Slack Web API][slack-web-api] This property references an instance of [`AsyncWebClient`][async-web-client] [slack-web-api]: https://api.slack.com/web [async-web-client]: https://slack.dev/python-slack-sdk/api-docs/slack_sdk/web/async_client.html#slack_sdk.web.async_client.AsyncWebClient # noqa: E501 \"\"\" return self . _client . web_client def find_channel_by_name ( self , channel_name : str ) -> Channel | None : \"\"\"Find a channel by its name, irrespective of a preceding pound symbol. This does not include DMs. :param channel_name: The name of the channel to retrieve. :return: The channel if found, None otherwise. \"\"\" if channel_name . startswith ( \"#\" ): channel_name = channel_name [ 1 :] for c in self . channels . values (): if c . name_normalized and channel_name . lower () == c . name_normalized . lower (): return c return None @property def bot_info ( self ) -> dict [ str , Any ]: \"\"\"Information about the bot user in Slack This will return a dictionary with information about the bot user in Slack that represents Slack Machine :return: Bot user \"\"\" return self . _client . bot_info def at ( self , user : User ) -> str : \"\"\"Create a mention of the provided user Create a mention of the provided user in the form of ``<@[user_id]>``. This method is convenient when you want to include mentions in your message. This method does not send a message, but should be used together with methods like :py:meth:`~machine.plugins.base.MachineBasePlugin.say` :param user: user your want to mention :return: user mention \"\"\" return user . fmt_mention () async def say ( self , channel : Channel | str , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , thread_ts : str | None = None , ephemeral_user : User | str | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Send a message to a channel Send a message to a channel using the WebAPI. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply in-thread and send ephemeral messages, visible to only one user. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral_user`` takes precedence over ``thread_ts`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send message to. Can be public or private (group) channel, or DM channel. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :param ephemeral_user: optional user name or id if the message needs to visible to a specific user only :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral_user` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" return await self . _client . send ( channel , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ephemeral_user = ephemeral_user , ** kwargs , ) async def say_scheduled ( self , when : datetime , channel : Channel | str , text : str , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , thread_ts : str | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Schedule a message to a channel This is the scheduled version of :py:meth:`~machine.plugins.base.MachineBasePlugin.say`. It behaves the same, but will send the message at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send message to. Can be public or private (group) channel, or DM channel. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" return await self . _client . send_scheduled ( when , channel , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ** kwargs , ) async def react ( self , channel : Channel | str , ts : str , emoji : str ) -> AsyncSlackResponse : \"\"\"React to a message in a channel Add a reaction to a message in a channel. What message to react to, is determined by the combination of the channel and the timestamp of the message. :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send message to. Can be public or private (group) channel, or DM channel. :param ts: timestamp of the message to react to :param emoji: what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) :return: Dictionary deserialized from `reactions.add`_ request. .. _reactions.add: https://api.slack.com/methods/reactions.add \"\"\" return await self . _client . react ( channel , ts , emoji ) async def send_dm ( self , user : User | str , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Send a Direct Message Send a Direct Message to a user by opening a DM channel and sending a message to it. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param user: :py:class:`~machine.models.user.User` object or id of user to send DM to. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: Dictionary deserialized from `chat.postMessage`_ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage \"\"\" return await self . _client . send_dm ( user , text , attachments = attachments , blocks = blocks , ** kwargs ) async def send_dm_scheduled ( self , when : datetime , user : User | str , text : str , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Schedule a Direct Message This is the scheduled version of :py:meth:`~machine.plugins.base.MachineBasePlugin.send_dm`. It behaves the same, but will send the DM at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param user: :py:class:`~machine.models.user.User` object or id of user to send DM to. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" return await self . _client . send_dm_scheduled ( when , user , text = text , attachments = attachments , blocks = blocks , ** kwargs ) def emit ( self , event : str , ** kwargs : Any ) -> None : \"\"\"Emit an event Emit an event that plugins can listen for. You can include arbitrary data as keyword arguments. :param event: name of the event :param **kwargs: any data you want to emit with the event :return: None \"\"\" ee . emit ( event , self , ** kwargs ) async def pin_message ( self , channel : Channel | str , ts : str ) -> AsyncSlackResponse : \"\"\"Pin message Pin a message in a channel :param channel: channel to pin the message in :param ts: timestamp of the message to pin :return: response from the Slack Web API \"\"\" return await self . _client . pin_message ( channel , ts ) async def unpin_message ( self , channel : Channel | str , ts : str ) -> AsyncSlackResponse : \"\"\"Unpin message Unpin a message that was previously pinned in a channel :param channel: channel where the message is pinned that needs to be unpinned :param ts: timestamp of the message to unpin :return: response from the Slack Web API \"\"\" return await self . _client . unpin_message ( channel , ts ) init () -> None Initialize plugin This method can be implemented by concrete plugin classes. It will be called once for each plugin, when that plugin is first loaded. You can refer to settings via self.settings , and access storage through self.storage , but the Slack client has not been initialized yet, so you cannot send or process messages during initialization. Returns: Type Description None None Source code in machine/plugins/base.py 46 47 48 49 50 51 52 53 54 55 56 def init ( self ) -> None : \"\"\"Initialize plugin This method can be implemented by concrete plugin classes. It will be called **once** for each plugin, when that plugin is first loaded. You can refer to settings via ``self.settings``, and access storage through ``self.storage``, but the Slack client has not been initialized yet, so you cannot send or process messages during initialization. :return: None \"\"\" pass users () -> dict [ str , User ] property Dictionary of all users in the Slack workspace Returns: Type Description dict [ str , User ] a dictionary of all users in the Slack workspace, where the key is the user id and the value is a User object Source code in machine/plugins/base.py 58 59 60 61 62 63 64 65 @property def users ( self ) -> dict [ str , User ]: \"\"\"Dictionary of all users in the Slack workspace :return: a dictionary of all users in the Slack workspace, where the key is the user id and the value is a [`User`][machine.models.user.User] object \"\"\" return self . _client . users channels () -> dict [ str , Channel ] property List of all channels in the Slack workspace This is a list of all channels in the Slack workspace that the bot is aware of. This includes all public channels, all private channels the bot is a member of and all DM channels the bot is a member of. Returns: Type Description dict [ str , Channel ] a list of all channels in the Slack workspace, where each channel is a :py:class: ~machine.models.channel.Channel object Source code in machine/plugins/base.py 67 68 69 70 71 72 73 74 75 76 77 78 @property def channels ( self ) -> dict [ str , Channel ]: \"\"\"List of all channels in the Slack workspace This is a list of all channels in the Slack workspace that the bot is aware of. This includes all public channels, all private channels the bot is a member of and all DM channels the bot is a member of. :return: a list of all channels in the Slack workspace, where each channel is a :py:class:`~machine.models.channel.Channel` object \"\"\" return self . _client . channels web_client () -> AsyncWebClient property Slack SDK web client to access the Slack Web API This property references an instance of AsyncWebClient [async-web-client]: https://slack.dev/python-slack-sdk/api-docs/slack_sdk/web/async_client.html#slack_sdk.web.async_client.AsyncWebClient # noqa: E501 Source code in machine/plugins/base.py 80 81 82 83 84 85 86 87 88 89 @property def web_client ( self ) -> AsyncWebClient : \"\"\"Slack SDK web client to access the [Slack Web API][slack-web-api] This property references an instance of [`AsyncWebClient`][async-web-client] [slack-web-api]: https://api.slack.com/web [async-web-client]: https://slack.dev/python-slack-sdk/api-docs/slack_sdk/web/async_client.html#slack_sdk.web.async_client.AsyncWebClient # noqa: E501 \"\"\" return self . _client . web_client find_channel_by_name ( channel_name : str ) -> Channel | None Find a channel by its name, irrespective of a preceding pound symbol. This does not include DMs. Parameters: Name Type Description Default channel_name str The name of the channel to retrieve. required Returns: Type Description Channel | None The channel if found, None otherwise. Source code in machine/plugins/base.py 91 92 93 94 95 96 97 98 99 100 101 102 def find_channel_by_name ( self , channel_name : str ) -> Channel | None : \"\"\"Find a channel by its name, irrespective of a preceding pound symbol. This does not include DMs. :param channel_name: The name of the channel to retrieve. :return: The channel if found, None otherwise. \"\"\" if channel_name . startswith ( \"#\" ): channel_name = channel_name [ 1 :] for c in self . channels . values (): if c . name_normalized and channel_name . lower () == c . name_normalized . lower (): return c return None bot_info () -> dict [ str , Any ] property Information about the bot user in Slack This will return a dictionary with information about the bot user in Slack that represents Slack Machine Returns: Type Description dict [ str , Any ] Bot user Source code in machine/plugins/base.py 104 105 106 107 108 109 110 111 112 113 @property def bot_info ( self ) -> dict [ str , Any ]: \"\"\"Information about the bot user in Slack This will return a dictionary with information about the bot user in Slack that represents Slack Machine :return: Bot user \"\"\" return self . _client . bot_info at ( user : User ) -> str Create a mention of the provided user Create a mention of the provided user in the form of <@[user_id]> . This method is convenient when you want to include mentions in your message. This method does not send a message, but should be used together with methods like :py:meth: ~machine.plugins.base.MachineBasePlugin.say Parameters: Name Type Description Default user User user your want to mention required Returns: Type Description str user mention Source code in machine/plugins/base.py 115 116 117 118 119 120 121 122 123 124 125 126 def at ( self , user : User ) -> str : \"\"\"Create a mention of the provided user Create a mention of the provided user in the form of ``<@[user_id]>``. This method is convenient when you want to include mentions in your message. This method does not send a message, but should be used together with methods like :py:meth:`~machine.plugins.base.MachineBasePlugin.say` :param user: user your want to mention :return: user mention \"\"\" return user . fmt_mention () say ( channel : Channel | str , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , thread_ts : str | None = None , ephemeral_user : User | str | None = None , ** kwargs : Any ) -> AsyncSlackResponse async Send a message to a channel Send a message to a channel using the WebAPI. Allows for rich formatting using blocks and/or attachments . You can provide blocks and attachments as Python dicts or you can use the convenient classes that the underlying slack client provides. Can also reply in-thread and send ephemeral messages, visible to only one user. Ephemeral messages and threaded messages are mutually exclusive, and ephemeral_user takes precedence over thread_ts Any extra kwargs you provide, will be passed on directly to the chat.postMessage or chat.postEphemeral _ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes Parameters: Name Type Description Default channel Channel | str :py:class: ~machine.models.channel.Channel object or id of channel to send message to. Can be public or private (group) channel, or DM channel. required text str | None message text None attachments Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None optional attachments (see attachments _) None blocks Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None optional blocks (see blocks _) None thread_ts str | None optional timestamp of thread, to send a message in that thread None ephemeral_user User | str | None optional user name or id if the message needs to visible to a specific user only None Returns: Type Description AsyncSlackResponse Dictionary deserialized from chat.postMessage request, or chat.postEphemeral if ephemeral_user is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral Source code in machine/plugins/base.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 async def say ( self , channel : Channel | str , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , thread_ts : str | None = None , ephemeral_user : User | str | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Send a message to a channel Send a message to a channel using the WebAPI. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply in-thread and send ephemeral messages, visible to only one user. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral_user`` takes precedence over ``thread_ts`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send message to. Can be public or private (group) channel, or DM channel. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :param ephemeral_user: optional user name or id if the message needs to visible to a specific user only :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral_user` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" return await self . _client . send ( channel , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ephemeral_user = ephemeral_user , ** kwargs , ) say_scheduled ( when : datetime , channel : Channel | str , text : str , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , thread_ts : str | None = None , ** kwargs : Any ) -> AsyncSlackResponse async Schedule a message to a channel This is the scheduled version of :py:meth: ~machine.plugins.base.MachineBasePlugin.say . It behaves the same, but will send the message at the scheduled time. Parameters: Name Type Description Default when datetime when you want the message to be sent, as :py:class: datetime.datetime instance required channel Channel | str :py:class: ~machine.models.channel.Channel object or id of channel to send message to. Can be public or private (group) channel, or DM channel. required text str message text required attachments Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None optional attachments (see attachments _) None blocks Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None optional blocks (see blocks _) None thread_ts str | None optional timestamp of thread, to send a message in that thread None Returns: Type Description AsyncSlackResponse None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks Source code in machine/plugins/base.py 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 async def say_scheduled ( self , when : datetime , channel : Channel | str , text : str , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , thread_ts : str | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Schedule a message to a channel This is the scheduled version of :py:meth:`~machine.plugins.base.MachineBasePlugin.say`. It behaves the same, but will send the message at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send message to. Can be public or private (group) channel, or DM channel. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" return await self . _client . send_scheduled ( when , channel , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ** kwargs , ) react ( channel : Channel | str , ts : str , emoji : str ) -> AsyncSlackResponse async React to a message in a channel Add a reaction to a message in a channel. What message to react to, is determined by the combination of the channel and the timestamp of the message. Parameters: Name Type Description Default channel Channel | str :py:class: ~machine.models.channel.Channel object or id of channel to send message to. Can be public or private (group) channel, or DM channel. required ts str timestamp of the message to react to required emoji str what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) required Returns: Type Description AsyncSlackResponse Dictionary deserialized from reactions.add _ request. .. _reactions.add: https://api.slack.com/methods/reactions.add Source code in machine/plugins/base.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 async def react ( self , channel : Channel | str , ts : str , emoji : str ) -> AsyncSlackResponse : \"\"\"React to a message in a channel Add a reaction to a message in a channel. What message to react to, is determined by the combination of the channel and the timestamp of the message. :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send message to. Can be public or private (group) channel, or DM channel. :param ts: timestamp of the message to react to :param emoji: what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) :return: Dictionary deserialized from `reactions.add`_ request. .. _reactions.add: https://api.slack.com/methods/reactions.add \"\"\" return await self . _client . react ( channel , ts , emoji ) send_dm ( user : User | str , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , ** kwargs : Any ) -> AsyncSlackResponse async Send a Direct Message Send a Direct Message to a user by opening a DM channel and sending a message to it. Allows for rich formatting using blocks and/or attachments . You can provide blocks and attachments as Python dicts or you can use the convenient classes that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the chat.postMessage request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes Parameters: Name Type Description Default user User | str :py:class: ~machine.models.user.User object or id of user to send DM to. required text str | None message text None attachments Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None optional attachments (see attachments _) None blocks Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None optional blocks (see blocks _) None Returns: Type Description AsyncSlackResponse Dictionary deserialized from chat.postMessage _ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage Source code in machine/plugins/base.py 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 async def send_dm ( self , user : User | str , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Send a Direct Message Send a Direct Message to a user by opening a DM channel and sending a message to it. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param user: :py:class:`~machine.models.user.User` object or id of user to send DM to. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: Dictionary deserialized from `chat.postMessage`_ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage \"\"\" return await self . _client . send_dm ( user , text , attachments = attachments , blocks = blocks , ** kwargs ) send_dm_scheduled ( when : datetime , user : User | str , text : str , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , ** kwargs : Any ) -> AsyncSlackResponse async Schedule a Direct Message This is the scheduled version of :py:meth: ~machine.plugins.base.MachineBasePlugin.send_dm . It behaves the same, but will send the DM at the scheduled time. Parameters: Name Type Description Default when datetime when you want the message to be sent, as :py:class: datetime.datetime instance required user User | str :py:class: ~machine.models.user.User object or id of user to send DM to. required text str message text required attachments Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None optional attachments (see attachments _) None blocks Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None optional blocks (see blocks _) None Returns: Type Description AsyncSlackResponse None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks Source code in machine/plugins/base.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 async def send_dm_scheduled ( self , when : datetime , user : User | str , text : str , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Schedule a Direct Message This is the scheduled version of :py:meth:`~machine.plugins.base.MachineBasePlugin.send_dm`. It behaves the same, but will send the DM at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param user: :py:class:`~machine.models.user.User` object or id of user to send DM to. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" return await self . _client . send_dm_scheduled ( when , user , text = text , attachments = attachments , blocks = blocks , ** kwargs ) emit ( event : str , ** kwargs : Any ) -> None Emit an event Emit an event that plugins can listen for. You can include arbitrary data as keyword arguments. Parameters: Name Type Description Default event str name of the event required **kwargs Any any data you want to emit with the event {} Returns: Type Description None None Source code in machine/plugins/base.py 291 292 293 294 295 296 297 298 299 300 301 def emit ( self , event : str , ** kwargs : Any ) -> None : \"\"\"Emit an event Emit an event that plugins can listen for. You can include arbitrary data as keyword arguments. :param event: name of the event :param **kwargs: any data you want to emit with the event :return: None \"\"\" ee . emit ( event , self , ** kwargs ) pin_message ( channel : Channel | str , ts : str ) -> AsyncSlackResponse async Pin message Pin a message in a channel Parameters: Name Type Description Default channel Channel | str channel to pin the message in required ts str timestamp of the message to pin required Returns: Type Description AsyncSlackResponse response from the Slack Web API Source code in machine/plugins/base.py 303 304 305 306 307 308 309 310 311 312 async def pin_message ( self , channel : Channel | str , ts : str ) -> AsyncSlackResponse : \"\"\"Pin message Pin a message in a channel :param channel: channel to pin the message in :param ts: timestamp of the message to pin :return: response from the Slack Web API \"\"\" return await self . _client . pin_message ( channel , ts ) unpin_message ( channel : Channel | str , ts : str ) -> AsyncSlackResponse async Unpin message Unpin a message that was previously pinned in a channel Parameters: Name Type Description Default channel Channel | str channel where the message is pinned that needs to be unpinned required ts str timestamp of the message to unpin required Returns: Type Description AsyncSlackResponse response from the Slack Web API Source code in machine/plugins/base.py 314 315 316 317 318 319 320 321 322 323 async def unpin_message ( self , channel : Channel | str , ts : str ) -> AsyncSlackResponse : \"\"\"Unpin message Unpin a message that was previously pinned in a channel :param channel: channel where the message is pinned that needs to be unpinned :param ts: timestamp of the message to unpin :return: response from the Slack Web API \"\"\" return await self . _client . unpin_message ( channel , ts ) machine.plugins.base.Message A message that was received by the bot This class represents a message that was received by the bot and passed to one or more plugins. It contains the message (text) itself, and metadata about the message, such as the sender of the message, the channel the message was sent to. The Message class also contains convenience methods for replying to the message in the right channel, replying to the sender, etc. Source code in machine/plugins/base.py 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 class Message : \"\"\"A message that was received by the bot This class represents a message that was received by the bot and passed to one or more plugins. It contains the message (text) itself, and metadata about the message, such as the sender of the message, the channel the message was sent to. The ``Message`` class also contains convenience methods for replying to the message in the right channel, replying to the sender, etc. \"\"\" # TODO: create proper class for msg_event def __init__ ( self , client : SlackClient , msg_event : dict [ str , Any ], plugin_class_name : str ): self . _client = client self . _msg_event = msg_event self . _fq_plugin_name = plugin_class_name @property def sender ( self ) -> User : \"\"\"The sender of the message :return: the User the message was sent by \"\"\" return self . _client . users [ self . _msg_event [ \"user\" ]] @property def channel ( self ) -> Channel : \"\"\"The channel the message was sent to :return: the Channel the message was sent to \"\"\" return self . _client . channels [ self . _msg_event [ \"channel\" ]] @property def is_dm ( self ) -> bool : channel_id = self . _msg_event [ \"channel\" ] return not ( channel_id . startswith ( \"C\" ) or channel_id . startswith ( \"G\" )) @property def text ( self ) -> str : \"\"\"The body of the actual message :return: the body (text) of the actual message \"\"\" return self . _msg_event [ \"text\" ] @property def at_sender ( self ) -> str : \"\"\"The sender of the message formatted as mention :return: a string representation of the sender of the message, formatted as `mention`_, to be used in messages .. _mention: https://api.slack.com/docs/message-formatting#linking_to_channels_and_users \"\"\" return self . sender . fmt_mention () async def say ( self , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , thread_ts : str | None = None , ephemeral : bool = False , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Send a new message to the channel the original message was received in Send a new message to the channel the original message was received in, using the WebAPI. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral`` takes precedence over ``thread_ts`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only visible to the sender of the original message :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" if ephemeral : ephemeral_user = self . sender . id else : ephemeral_user = None return await self . _client . send ( self . channel . id , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ephemeral_user = ephemeral_user , ** kwargs , ) async def say_scheduled ( self , when : datetime , text : str , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , thread_ts : str | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Schedule a message This is the scheduled version of :py:meth:`~machine.plugins.base.Message.say`. It behaves the same, but will send the message at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" return await self . _client . send_scheduled ( when , self . channel . id , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ** kwargs , ) async def reply ( self , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , in_thread : bool = False , ephemeral : bool = False , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Reply to the sender of the original message Reply to the sender of the original message with a new message, mentioning that user. Rich formatting using `blocks`_ and/or `attachments`_ is possible. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. In the case of in-thread response, the sender of the original message will not be mentioned. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral`` takes precedence over ``in_thread`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param in_thread: ``True/False`` wether to reply to the original message in-thread :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only visible to the sender of the original message :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" if in_thread and not ephemeral : return await self . say ( text , attachments = attachments , blocks = blocks , thread_ts = self . ts , ** kwargs ) else : text = self . _create_reply ( text ) return await self . say ( text , attachments = attachments , blocks = blocks , ephemeral = ephemeral , ** kwargs ) async def reply_scheduled ( self , when : datetime , text : str , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , in_thread : bool = False , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Schedule a reply and send it This is the scheduled version of :py:meth:`~machine.plugins.base.Message.reply`. It behaves the same, but will send the reply at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param in_thread: ``True/False`` wether to reply to the original message in-thread :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" if in_thread : return await self . say_scheduled ( when , text , attachments = attachments , blocks = blocks , thread_ts = self . ts , ** kwargs ) else : text = cast ( str , self . _create_reply ( text )) return await self . say_scheduled ( when , text , attachments = attachments , blocks = blocks , ** kwargs ) async def reply_dm ( self , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Reply to the sender of the original message with a DM Reply in a Direct Message to the sender of the original message by opening a DM channel and sending a message to it. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: Dictionary deserialized from `chat.postMessage`_ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage \"\"\" return await self . _client . send_dm ( self . sender . id , text , attachments = attachments , blocks = blocks , ** kwargs ) async def reply_dm_scheduled ( self , when : datetime , text : str , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Schedule a DM reply and send it This is the scheduled version of :py:meth:`~machine.plugins.base.Message.reply_dm`. It behaves the same, but will send the DM at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" return await self . _client . send_dm_scheduled ( when , self . sender . id , text = text , attachments = attachments , blocks = blocks , ** kwargs ) async def react ( self , emoji : str ) -> AsyncSlackResponse : \"\"\"React to the original message Add a reaction to the original message :param emoji: what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) :return: Dictionary deserialized from `reactions.add`_ request. .. _reactions.add: https://api.slack.com/methods/reactions.add \"\"\" return await self . _client . react ( self . channel . id , self . _msg_event [ \"ts\" ], emoji ) def _create_reply ( self , text : str | None ) -> str | None : if not self . is_dm and text is not None : return f \" { self . at_sender } : { text } \" else : return text @property def ts ( self ) -> str : \"\"\"The timestamp of the message :return: the timestamp of the message \"\"\" return self . _msg_event [ \"ts\" ] @property def in_thread ( self ) -> bool : \"\"\"Is message in a thread :return: bool \"\"\" return \"thread_ts\" in self . _msg_event async def pin_message ( self ) -> AsyncSlackResponse : \"\"\"Pin message Pin the current message in the channel it was posted in \"\"\" return await self . _client . pin_message ( self . channel , self . ts ) def __str__ ( self ) -> str : if self . channel . is_im : message = f \"Message ' { self . text } ', sent by user @ { self . sender . profile . real_name } in DM\" else : message = ( f \"Message ' { self . text } ', sent by user @ { self . sender . profile . real_name } in channel # { self . channel . name } \" ) return message def __repr__ ( self ) -> str : return f \"Message(text= { self . text !r} , sender= { self . sender . profile . real_name !r} , channel= { self . channel . name !r} )\" sender () -> User property The sender of the message Returns: Type Description User the User the message was sent by Source code in machine/plugins/base.py 343 344 345 346 347 348 349 @property def sender ( self ) -> User : \"\"\"The sender of the message :return: the User the message was sent by \"\"\" return self . _client . users [ self . _msg_event [ \"user\" ]] channel () -> Channel property The channel the message was sent to Returns: Type Description Channel the Channel the message was sent to Source code in machine/plugins/base.py 351 352 353 354 355 356 357 @property def channel ( self ) -> Channel : \"\"\"The channel the message was sent to :return: the Channel the message was sent to \"\"\" return self . _client . channels [ self . _msg_event [ \"channel\" ]] text () -> str property The body of the actual message Returns: Type Description str the body (text) of the actual message Source code in machine/plugins/base.py 364 365 366 367 368 369 370 @property def text ( self ) -> str : \"\"\"The body of the actual message :return: the body (text) of the actual message \"\"\" return self . _msg_event [ \"text\" ] at_sender () -> str property The sender of the message formatted as mention Returns: Type Description str a string representation of the sender of the message, formatted as mention _, to be used in messages .. _mention: https://api.slack.com/docs/message-formatting#linking_to_channels_and_users Source code in machine/plugins/base.py 372 373 374 375 376 377 378 379 380 381 @property def at_sender ( self ) -> str : \"\"\"The sender of the message formatted as mention :return: a string representation of the sender of the message, formatted as `mention`_, to be used in messages .. _mention: https://api.slack.com/docs/message-formatting#linking_to_channels_and_users \"\"\" return self . sender . fmt_mention () say ( text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , thread_ts : str | None = None , ephemeral : bool = False , ** kwargs : Any ) -> AsyncSlackResponse async Send a new message to the channel the original message was received in Send a new message to the channel the original message was received in, using the WebAPI. Allows for rich formatting using blocks and/or attachments . You can provide blocks and attachments as Python dicts or you can use the convenient classes that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. Ephemeral messages and threaded messages are mutually exclusive, and ephemeral takes precedence over thread_ts Any extra kwargs you provide, will be passed on directly to the chat.postMessage or chat.postEphemeral _ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes Parameters: Name Type Description Default text str | None message text None attachments Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None optional attachments (see attachments _) None blocks Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None optional blocks (see blocks _) None thread_ts str | None optional timestamp of thread, to send a message in that thread None ephemeral bool True/False wether to send the message as an ephemeral message, only visible to the sender of the original message False Returns: Type Description AsyncSlackResponse Dictionary deserialized from chat.postMessage request, or chat.postEphemeral if ephemeral is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral Source code in machine/plugins/base.py 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 async def say ( self , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , thread_ts : str | None = None , ephemeral : bool = False , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Send a new message to the channel the original message was received in Send a new message to the channel the original message was received in, using the WebAPI. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral`` takes precedence over ``thread_ts`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only visible to the sender of the original message :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" if ephemeral : ephemeral_user = self . sender . id else : ephemeral_user = None return await self . _client . send ( self . channel . id , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ephemeral_user = ephemeral_user , ** kwargs , ) say_scheduled ( when : datetime , text : str , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , thread_ts : str | None = None , ** kwargs : Any ) -> AsyncSlackResponse async Schedule a message This is the scheduled version of :py:meth: ~machine.plugins.base.Message.say . It behaves the same, but will send the message at the scheduled time. Parameters: Name Type Description Default when datetime when you want the message to be sent, as :py:class: datetime.datetime instance required text str message text required attachments Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None optional attachments (see attachments _) None blocks Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None optional blocks (see blocks _) None thread_ts str | None optional timestamp of thread, to send a message in that thread None Returns: Type Description AsyncSlackResponse None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks Source code in machine/plugins/base.py 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 async def say_scheduled ( self , when : datetime , text : str , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , thread_ts : str | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Schedule a message This is the scheduled version of :py:meth:`~machine.plugins.base.Message.say`. It behaves the same, but will send the message at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" return await self . _client . send_scheduled ( when , self . channel . id , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ** kwargs , ) reply ( text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , in_thread : bool = False , ephemeral : bool = False , ** kwargs : Any ) -> AsyncSlackResponse async Reply to the sender of the original message Reply to the sender of the original message with a new message, mentioning that user. Rich formatting using blocks and/or attachments is possible. You can provide blocks and attachments as Python dicts or you can use the convenient classes that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. In the case of in-thread response, the sender of the original message will not be mentioned. Ephemeral messages and threaded messages are mutually exclusive, and ephemeral takes precedence over in_thread Any extra kwargs you provide, will be passed on directly to the chat.postMessage or chat.postEphemeral _ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes Parameters: Name Type Description Default text str | None message text None attachments Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None optional attachments (see attachments _) None blocks Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None optional blocks (see blocks _) None in_thread bool True/False wether to reply to the original message in-thread False ephemeral bool True/False wether to send the message as an ephemeral message, only visible to the sender of the original message False Returns: Type Description AsyncSlackResponse Dictionary deserialized from chat.postMessage request, or chat.postEphemeral if ephemeral is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral Source code in machine/plugins/base.py 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 async def reply ( self , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , in_thread : bool = False , ephemeral : bool = False , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Reply to the sender of the original message Reply to the sender of the original message with a new message, mentioning that user. Rich formatting using `blocks`_ and/or `attachments`_ is possible. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. In the case of in-thread response, the sender of the original message will not be mentioned. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral`` takes precedence over ``in_thread`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param in_thread: ``True/False`` wether to reply to the original message in-thread :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only visible to the sender of the original message :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" if in_thread and not ephemeral : return await self . say ( text , attachments = attachments , blocks = blocks , thread_ts = self . ts , ** kwargs ) else : text = self . _create_reply ( text ) return await self . say ( text , attachments = attachments , blocks = blocks , ephemeral = ephemeral , ** kwargs ) reply_scheduled ( when : datetime , text : str , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , in_thread : bool = False , ** kwargs : Any ) -> AsyncSlackResponse async Schedule a reply and send it This is the scheduled version of :py:meth: ~machine.plugins.base.Message.reply . It behaves the same, but will send the reply at the scheduled time. Parameters: Name Type Description Default when datetime when you want the message to be sent, as :py:class: datetime.datetime instance required text str message text required attachments Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None optional attachments (see attachments _) None blocks Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None optional blocks (see blocks _) None in_thread bool True/False wether to reply to the original message in-thread False Returns: Type Description AsyncSlackResponse None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks Source code in machine/plugins/base.py 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 async def reply_scheduled ( self , when : datetime , text : str , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , in_thread : bool = False , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Schedule a reply and send it This is the scheduled version of :py:meth:`~machine.plugins.base.Message.reply`. It behaves the same, but will send the reply at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param in_thread: ``True/False`` wether to reply to the original message in-thread :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" if in_thread : return await self . say_scheduled ( when , text , attachments = attachments , blocks = blocks , thread_ts = self . ts , ** kwargs ) else : text = cast ( str , self . _create_reply ( text )) return await self . say_scheduled ( when , text , attachments = attachments , blocks = blocks , ** kwargs ) reply_dm ( text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , ** kwargs : Any ) -> AsyncSlackResponse async Reply to the sender of the original message with a DM Reply in a Direct Message to the sender of the original message by opening a DM channel and sending a message to it. Allows for rich formatting using blocks and/or attachments . You can provide blocks and attachments as Python dicts or you can use the convenient classes that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the chat.postMessage request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes Parameters: Name Type Description Default text str | None message text None attachments Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None optional attachments (see attachments _) None blocks Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None optional blocks (see blocks _) None Returns: Type Description AsyncSlackResponse Dictionary deserialized from chat.postMessage _ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage Source code in machine/plugins/base.py 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 async def reply_dm ( self , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Reply to the sender of the original message with a DM Reply in a Direct Message to the sender of the original message by opening a DM channel and sending a message to it. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: Dictionary deserialized from `chat.postMessage`_ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage \"\"\" return await self . _client . send_dm ( self . sender . id , text , attachments = attachments , blocks = blocks , ** kwargs ) reply_dm_scheduled ( when : datetime , text : str , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , ** kwargs : Any ) -> AsyncSlackResponse async Schedule a DM reply and send it This is the scheduled version of :py:meth: ~machine.plugins.base.Message.reply_dm . It behaves the same, but will send the DM at the scheduled time. Parameters: Name Type Description Default when datetime when you want the message to be sent, as :py:class: datetime.datetime instance required text str message text required attachments Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None optional attachments (see attachments _) None blocks Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None optional blocks (see blocks _) None Returns: Type Description AsyncSlackResponse None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks Source code in machine/plugins/base.py 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 async def reply_dm_scheduled ( self , when : datetime , text : str , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Schedule a DM reply and send it This is the scheduled version of :py:meth:`~machine.plugins.base.Message.reply_dm`. It behaves the same, but will send the DM at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" return await self . _client . send_dm_scheduled ( when , self . sender . id , text = text , attachments = attachments , blocks = blocks , ** kwargs ) react ( emoji : str ) -> AsyncSlackResponse async React to the original message Add a reaction to the original message Parameters: Name Type Description Default emoji str what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) required Returns: Type Description AsyncSlackResponse Dictionary deserialized from reactions.add _ request. .. _reactions.add: https://api.slack.com/methods/reactions.add Source code in machine/plugins/base.py 602 603 604 605 606 607 608 609 610 611 612 async def react ( self , emoji : str ) -> AsyncSlackResponse : \"\"\"React to the original message Add a reaction to the original message :param emoji: what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) :return: Dictionary deserialized from `reactions.add`_ request. .. _reactions.add: https://api.slack.com/methods/reactions.add \"\"\" return await self . _client . react ( self . channel . id , self . _msg_event [ \"ts\" ], emoji ) ts () -> str property The timestamp of the message Returns: Type Description str the timestamp of the message Source code in machine/plugins/base.py 620 621 622 623 624 625 626 @property def ts ( self ) -> str : \"\"\"The timestamp of the message :return: the timestamp of the message \"\"\" return self . _msg_event [ \"ts\" ] in_thread () -> bool property Is message in a thread Returns: Type Description bool bool Source code in machine/plugins/base.py 628 629 630 631 632 633 634 @property def in_thread ( self ) -> bool : \"\"\"Is message in a thread :return: bool \"\"\" return \"thread_ts\" in self . _msg_event pin_message () -> AsyncSlackResponse async Pin message Pin the current message in the channel it was posted in Source code in machine/plugins/base.py 636 637 638 639 640 641 async def pin_message ( self ) -> AsyncSlackResponse : \"\"\"Pin message Pin the current message in the channel it was posted in \"\"\" return await self . _client . pin_message ( self . channel , self . ts ) Decorators These are the decorators you can use to have Slack Machine respond to specific things (events, messages, etc.) machine.plugins.decorators process ( slack_event_type : str ) -> Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]] Process Slack events of a specific type This decorator will enable a Plugin method to process Slack events _ of a specific type. The Plugin method will be called for each event of the specified type that the bot receives. The received event will be passed to the method when called. .. _Slack events: https://api.slack.com/events Parameters: Name Type Description Default slack_event_type str type of event the method needs to process. Can be any event supported by the RTM API required Returns: Type Description Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]] wrapped method Source code in machine/plugins/decorators.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def process ( slack_event_type : str ) -> Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]]: \"\"\"Process Slack events of a specific type This decorator will enable a Plugin method to process `Slack events`_ of a specific type. The Plugin method will be called for each event of the specified type that the bot receives. The received event will be passed to the method when called. .. _Slack events: https://api.slack.com/events :param slack_event_type: type of event the method needs to process. Can be any event supported by the RTM API :return: wrapped method \"\"\" def process_decorator ( f : Callable [ P , R ]) -> DecoratedPluginFunc [ P , R ]: fn = cast ( DecoratedPluginFunc , f ) fn . metadata = getattr ( f , \"metadata\" , Metadata ()) fn . metadata . plugin_actions . process . append ( slack_event_type ) return fn return process_decorator listen_to ( regex : str , flags : re . RegexFlag | int = re . IGNORECASE , handle_message_changed : bool = False ) -> Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]] Listen to messages matching a regex pattern This decorator will enable a Plugin method to listen to messages that match a regex pattern. The Plugin method will be called for each message that matches the specified regex pattern. The received :py:class: ~machine.plugins.base.Message will be passed to the method when called. Named groups can be used in the regex pattern, to catch specific parts of the message. These groups will be passed to the method as keyword arguments when called. Parameters: Name Type Description Default regex str regex pattern to listen for required flags re . RegexFlag | int regex flags to apply when matching re.IGNORECASE handle_message_changed bool if changed messages should trigger the decorated function False Returns: Type Description Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]] wrapped method Source code in machine/plugins/decorators.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def listen_to ( regex : str , flags : re . RegexFlag | int = re . IGNORECASE , handle_message_changed : bool = False ) -> Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]]: \"\"\"Listen to messages matching a regex pattern This decorator will enable a Plugin method to listen to messages that match a regex pattern. The Plugin method will be called for each message that matches the specified regex pattern. The received :py:class:`~machine.plugins.base.Message` will be passed to the method when called. Named groups can be used in the regex pattern, to catch specific parts of the message. These groups will be passed to the method as keyword arguments when called. :param regex: regex pattern to listen for :param flags: regex flags to apply when matching :param handle_message_changed: if changed messages should trigger the decorated function :return: wrapped method \"\"\" def listen_to_decorator ( f : Callable [ P , R ]) -> DecoratedPluginFunc [ P , R ]: fn = cast ( DecoratedPluginFunc , f ) fn . metadata = getattr ( f , \"metadata\" , Metadata ()) fn . metadata . plugin_actions . listen_to . append ( MatcherConfig ( re . compile ( regex , flags ), handle_message_changed )) return fn return listen_to_decorator respond_to ( regex : str , flags : re . RegexFlag | int = re . IGNORECASE , handle_message_changed : bool = False ) -> Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]] Listen to messages mentioning the bot and matching a regex pattern This decorator will enable a Plugin method to listen to messages that are directed to the bot (ie. message starts by mentioning the bot) and match a regex pattern. The Plugin method will be called for each message that mentions the bot and matches the specified regex pattern. The received :py:class: ~machine.plugins.base.Message will be passed to the method when called. Named groups can be used in the regex pattern, to catch specific parts of the message. These groups will be passed to the method as keyword arguments when called. Parameters: Name Type Description Default regex str regex pattern to listen for required flags re . RegexFlag | int regex flags to apply when matching re.IGNORECASE handle_message_changed bool if changed messages should trigger the decorated function False Returns: Type Description Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]] wrapped method Source code in machine/plugins/decorators.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def respond_to ( regex : str , flags : re . RegexFlag | int = re . IGNORECASE , handle_message_changed : bool = False ) -> Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]]: \"\"\"Listen to messages mentioning the bot and matching a regex pattern This decorator will enable a Plugin method to listen to messages that are directed to the bot (ie. message starts by mentioning the bot) and match a regex pattern. The Plugin method will be called for each message that mentions the bot and matches the specified regex pattern. The received :py:class:`~machine.plugins.base.Message` will be passed to the method when called. Named groups can be used in the regex pattern, to catch specific parts of the message. These groups will be passed to the method as keyword arguments when called. :param regex: regex pattern to listen for :param flags: regex flags to apply when matching :param handle_message_changed: if changed messages should trigger the decorated function :return: wrapped method \"\"\" def respond_to_decorator ( f : Callable [ P , R ]) -> DecoratedPluginFunc [ P , R ]: fn = cast ( DecoratedPluginFunc , f ) fn . metadata = getattr ( f , \"metadata\" , Metadata ()) fn . metadata . plugin_actions . respond_to . append ( MatcherConfig ( re . compile ( regex , flags ), handle_message_changed )) return fn return respond_to_decorator schedule ( year : int | str | None = None , month : int | str | None = None , day : int | str | None = None , week : int | str | None = None , day_of_week : int | str | None = None , hour : int | str | None = None , minute : int | str | None = None , second : int | str | None = None , start_date : datetime | str | None = None , end_date : datetime | str | None = None , timezone : tzinfo | str | None = None ) -> Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]] Schedule a function to be executed according to a crontab-like schedule The decorated function will be executed according to the schedule provided. Slack Machine uses APScheduler under the hood for scheduling. For more information on the interpretation of the provided parameters, see :class: CronTrigger<apscheduler:apscheduler.triggers.cron.CronTrigger> Parameters: Name Type Description Default year int|str 4-digit year None month int|str month (1-12) None day int|str day of the (1-31) None week int|str ISO week (1-53) None day_of_week int|str number or name of weekday (0-6 or mon,tue,wed,thu,fri,sat,sun) None hour int|str hour (0-23) None minute int|str minute (0-59) None second int|str second (0-59) None start_date datetime|str earliest possible date/time to trigger on (inclusive) None end_date datetime|str latest possible date/time to trigger on (inclusive) None timezone datetime.tzinfo|str time zone to use for the date/time calculations (defaults to scheduler timezone) None Source code in machine/plugins/decorators.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def schedule ( year : int | str | None = None , month : int | str | None = None , day : int | str | None = None , week : int | str | None = None , day_of_week : int | str | None = None , hour : int | str | None = None , minute : int | str | None = None , second : int | str | None = None , start_date : datetime | str | None = None , end_date : datetime | str | None = None , timezone : tzinfo | str | None = None , ) -> Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]]: \"\"\"Schedule a function to be executed according to a crontab-like schedule The decorated function will be executed according to the schedule provided. Slack Machine uses APScheduler under the hood for scheduling. For more information on the interpretation of the provided parameters, see :class:`CronTrigger<apscheduler:apscheduler.triggers.cron.CronTrigger>` :param int|str year: 4-digit year :param int|str month: month (1-12) :param int|str day: day of the (1-31) :param int|str week: ISO week (1-53) :param int|str day_of_week: number or name of weekday (0-6 or mon,tue,wed,thu,fri,sat,sun) :param int|str hour: hour (0-23) :param int|str minute: minute (0-59) :param int|str second: second (0-59) :param datetime|str start_date: earliest possible date/time to trigger on (inclusive) :param datetime|str end_date: latest possible date/time to trigger on (inclusive) :param datetime.tzinfo|str timezone: time zone to use for the date/time calculations (defaults to scheduler timezone) \"\"\" kwargs = locals () def schedule_decorator ( f : Callable [ P , R ]) -> DecoratedPluginFunc [ P , R ]: fn = cast ( DecoratedPluginFunc , f ) fn . metadata = getattr ( f , \"metadata\" , Metadata ()) fn . metadata . plugin_actions . schedule = kwargs return fn return schedule_decorator on ( event : str ) -> Callable [[ Callable [ P , R ]], Callable [ P , R ]] Listen for an event The decorated function will be called whenever a plugin (or Slack Machine itself) emits an event with the given name. Parameters: Name Type Description Default event str name of the event to listen for. Event names are global required Source code in machine/plugins/decorators.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def on ( event : str ) -> Callable [[ Callable [ P , R ]], Callable [ P , R ]]: \"\"\"Listen for an event The decorated function will be called whenever a plugin (or Slack Machine itself) emits an event with the given name. :param event: name of the event to listen for. Event names are global \"\"\" def on_decorator ( f : Callable [ P , R ]) -> Callable [ P , R ]: ee . add_listener ( event , f ) return f return on_decorator required_settings ( settings : list [ str ] | str ) -> Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]] Specify a required setting for a plugin or plugin method The settings specified with this decorator will be added to the required settings for the plugin. If one or more settings have not been defined by the user, the plugin will not be loaded and a warning will be written to the console upon startup. Parameters: Name Type Description Default settings list [ str ] | str settings that are required (can be list of strings, or single string) required Source code in machine/plugins/decorators.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 def required_settings ( settings : list [ str ] | str ) -> Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]]: \"\"\"Specify a required setting for a plugin or plugin method The settings specified with this decorator will be added to the required settings for the plugin. If one or more settings have not been defined by the user, the plugin will not be loaded and a warning will be written to the console upon startup. :param settings: settings that are required (can be list of strings, or single string) \"\"\" def required_settings_decorator ( f_or_cls : Callable [ P , R ]) -> DecoratedPluginFunc [ P , R ]: casted_f_or_cls = cast ( DecoratedPluginFunc , f_or_cls ) casted_f_or_cls . metadata = getattr ( f_or_cls , \"metadata\" , Metadata ()) if isinstance ( settings , list ): casted_f_or_cls . metadata . required_settings . extend ( settings ) elif isinstance ( settings , str ): casted_f_or_cls . metadata . required_settings . append ( settings ) return casted_f_or_cls return required_settings_decorator require_any_role ( required_roles : list [ str ]) -> Callable [[ Callable [ ... , Awaitable [ None ]]], Callable [ ... , Awaitable [ None ]]] Specify required roles for a plugin method To use the plugin method where this decorator is applied, the user must have at least one of the listed roles. Parameters: Name Type Description Default required_roles list [ str ] list of roles required to use the plugin method required Source code in machine/plugins/decorators.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 def require_any_role ( required_roles : list [ str ], ) -> Callable [[ Callable [ ... , Awaitable [ None ]]], Callable [ ... , Awaitable [ None ]]]: \"\"\"Specify required roles for a plugin method To use the plugin method where this decorator is applied, the user must have at least one of the listed roles. :param required_roles: list of roles required to use the plugin method \"\"\" def middle ( func : Callable [ ... , Awaitable [ None ]]) -> Callable [ ... , Awaitable [ None ]]: async def wrapper ( self : MachineBasePlugin , msg : Message , ** kwargs : Any ) -> None : if await matching_roles_by_user_id ( self , msg . sender . id , required_roles ): logger . debug ( f \"User { msg . sender } has one of the required roles { required_roles } \" ) return await func ( self , msg , ** kwargs ) else : logger . debug ( f \"User { msg . sender } does not have any of the required roles { required_roles } \" ) ee . emit ( \"unauthorized-access\" , self , message = msg , required_roles = required_roles , combinator = RoleCombinator . ANY , ) await msg . say ( \"I'm sorry, but you don't have access to that command\" , ephemeral = True ) return None # Copy any existing docs and metadata from container function to # generated function wrapper . __doc__ = func . __doc__ casted_wrapper = cast ( DecoratedPluginFunc , wrapper ) casted_wrapper . metadata = getattr ( func , \"metadata\" , Metadata ()) return casted_wrapper return middle require_all_roles ( required_roles : list [ str ]) -> Callable [[ Callable [ ... , Awaitable [ None ]]], Callable [ ... , Awaitable [ None ]]] Specify required roles for a plugin method To use the plugin method where this decorator is applied, the user must have all of the listed roles. Parameters: Name Type Description Default required_roles list [ str ] list of roles required to use the plugin method required Source code in machine/plugins/decorators.py 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 def require_all_roles ( required_roles : list [ str ], ) -> Callable [[ Callable [ ... , Awaitable [ None ]]], Callable [ ... , Awaitable [ None ]]]: \"\"\"Specify required roles for a plugin method To use the plugin method where this decorator is applied, the user must have all of the listed roles. :param required_roles: list of roles required to use the plugin method \"\"\" def middle ( func : Callable [ ... , Awaitable [ None ]]) -> Callable [ ... , Awaitable [ None ]]: async def wrapper ( self : MachineBasePlugin , msg : Message , ** kwargs : Any ) -> None : if await matching_roles_by_user_id ( self , msg . sender . id , required_roles ) == len ( required_roles ): logger . debug ( f \"User { msg . sender } has all of the required roles { required_roles } \" ) return await func ( self , msg , ** kwargs ) else : logger . debug ( f \"User { msg . sender } does not have all of the required roles { required_roles } \" ) ee . emit ( \"unauthorized-access\" , self , message = msg , required_roles = required_roles , combinator = RoleCombinator . ALL , ) await msg . say ( \"I'm sorry, but you don't have access to that command\" , ephemeral = True ) return None # Copy any existing docs and metadata from container function to # generated function wrapper . __doc__ = func . __doc__ casted_wrapper = cast ( DecoratedPluginFunc , wrapper ) casted_wrapper . metadata = getattr ( func , \"metadata\" , Metadata ()) return casted_wrapper return middle Models These classes represent base objects from the Slack API machine.models.user.User Bases: BaseModel User model that represents a user object from the Slack API Source code in machine/models/user.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class User ( BaseModel ): \"\"\" User model that represents a user object from the Slack API \"\"\" id : str team_id : Optional [ str ] name : str deleted : Optional [ bool ] profile : Profile is_bot : bool updated : int is_app_user : bool color : Optional [ str ] = None real_name : Optional [ str ] = None tz : Optional [ str ] = None tz_label : Optional [ str ] = None tz_offset : Optional [ int ] = None is_admin : Optional [ bool ] = None is_owner : Optional [ bool ] = None is_primary_owner : Optional [ bool ] = None is_restricted : Optional [ bool ] = None is_ultra_restricted : Optional [ bool ] = None is_stranger : Optional [ bool ] = None has_2fa : Optional [ bool ] = None locale : Optional [ str ] = None class Config : allow_mutation = False def fmt_mention ( self ) -> str : return f \"<@ { self . id } >\" machine.models.channel.Channel Bases: BaseModel Channel model that represents a channel object from the Slack API Source code in machine/models/channel.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class Channel ( BaseModel ): \"\"\" Channel model that represents a channel object from the Slack API \"\"\" id : str name : Optional [ str ] created : int creator : Optional [ str ] is_archived : bool is_general : Optional [ bool ] name_normalized : Optional [ str ] is_shared : Optional [ bool ] is_org_shared : bool is_member : Optional [ bool ] is_private : Optional [ bool ] is_mpim : Optional [ bool ] is_channel : Optional [ bool ] is_group : Optional [ bool ] is_im : Optional [ bool ] user : Optional [ str ] topic : Optional [ PurposeTopic ] purpose : Optional [ PurposeTopic ] previous_names : Optional [ List [ str ]] @property def identifier ( self ) -> str : if self . name : return self . name else : return self . id class Config : allow_mutation = False Storage Storage is exposed to plugins through the self.storage field. The following class implements the interface plugins can use to interact with the storage backend. machine.storage.PluginStorage Class providing access to persistent storage for plugins This class is the main access point for plugins to work with persistent storage. It is accessible from plugins using self.storage . Data is serialized before sending it to the storage backend, and deserialized upon retrieval. Serialization is done by dill _, so pretty much any Python object can be stored and retrieved. .. _Dill: https://pypi.python.org/pypi/dill Source code in machine/storage/__init__.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 class PluginStorage : \"\"\"Class providing access to persistent storage for plugins This class is the main access point for plugins to work with persistent storage. It is accessible from plugins using ``self.storage``. Data is serialized before sending it to the storage backend, and deserialized upon retrieval. Serialization is done by `dill`_, so pretty much any Python object can be stored and retrieved. .. _Dill: https://pypi.python.org/pypi/dill \"\"\" def __init__ ( self , fq_plugin_name : str , storage_backend : MachineBaseStorage ): self . _fq_plugin_name = fq_plugin_name self . _storage = storage_backend def _gen_unique_key ( self , key : str ) -> str : return f \" { self . _fq_plugin_name } : { key } \" def _namespace_key ( self , key : str , shared : bool = False ) -> str : return key if shared else self . _gen_unique_key ( key ) async def set ( self , key : str , value : Any , expires : int | timedelta | None = None , shared : bool = False ) -> None : \"\"\"Store or update a value by key :param key: the key under which to store the data :param value: the data to store :param expires: optional number of seconds after which the data is expired :param shared: ``True/False`` wether this data should be shared by other plugins. Use with care, because it pollutes the global namespace of the storage. \"\"\" expires = int ( expires . total_seconds ()) if isinstance ( expires , timedelta ) else expires namespaced_key = self . _namespace_key ( key , shared ) pickled_value = dill . dumps ( value ) await self . _storage . set ( namespaced_key , pickled_value , expires ) async def get ( self , key : str , shared : bool = False ) -> Any | None : \"\"\"Retrieve data by key :param key: key for the data to retrieve :param shared: ``True/False`` wether to retrieve data from the shared (global) namespace. :return: the data, or ``None`` if the key cannot be found/has expired \"\"\" namespaced_key = self . _namespace_key ( key , shared ) value = await self . _storage . get ( namespaced_key ) if value : return dill . loads ( value ) else : return None async def has ( self , key : str , shared : bool = False ) -> bool : \"\"\"Check if the key exists in storage Note: this class implements ``__contains__`` so instead of calling ``self.storage.has(...)``, you can also use: ``key in self.storage``. This will check the *namespaced* version of the key, so it's the same as: ``self.storage.has('key', shared=False)`` :param key: key to check :param shared: ``True/False`` wether to check in the shared (global) namespace :return: ``True/False`` wether the key exists. Can only return ``True`` if the key has not expired. \"\"\" namespaced_key = self . _namespace_key ( key , shared ) return await self . _storage . has ( namespaced_key ) async def delete ( self , key : str , shared : bool = False ) -> None : \"\"\"Remove a key and its data from storage :param key: key to remove :param shared: ``True/False`` wether the key to remove should be in the shared (global) namespace \"\"\" namespaced_key = self . _namespace_key ( key , shared ) await self . _storage . delete ( namespaced_key ) async def get_storage_size ( self ) -> int : \"\"\"Calculate the total size of the storage :return: the total size of the storage in bytes (integer) \"\"\" return await self . _storage . size () async def get_storage_size_human ( self ) -> str : \"\"\"Calculate the total size of the storage in human readable format :return: the total size of the storage in a human readable string, rounded to the nearest applicable division. eg. B for Bytes, KiB for Kilobytes, MiB for Megabytes etc. \"\"\" size = await self . get_storage_size () return sizeof_fmt ( size ) set ( key : str , value : Any , expires : int | timedelta | None = None , shared : bool = False ) -> None async Store or update a value by key Parameters: Name Type Description Default key str the key under which to store the data required value Any the data to store required expires int | timedelta | None optional number of seconds after which the data is expired None shared bool True/False wether this data should be shared by other plugins. Use with care, because it pollutes the global namespace of the storage. False Source code in machine/storage/__init__.py 33 34 35 36 37 38 39 40 41 42 43 44 45 async def set ( self , key : str , value : Any , expires : int | timedelta | None = None , shared : bool = False ) -> None : \"\"\"Store or update a value by key :param key: the key under which to store the data :param value: the data to store :param expires: optional number of seconds after which the data is expired :param shared: ``True/False`` wether this data should be shared by other plugins. Use with care, because it pollutes the global namespace of the storage. \"\"\" expires = int ( expires . total_seconds ()) if isinstance ( expires , timedelta ) else expires namespaced_key = self . _namespace_key ( key , shared ) pickled_value = dill . dumps ( value ) await self . _storage . set ( namespaced_key , pickled_value , expires ) get ( key : str , shared : bool = False ) -> Any | None async Retrieve data by key Parameters: Name Type Description Default key str key for the data to retrieve required shared bool True/False wether to retrieve data from the shared (global) namespace. False Returns: Type Description Any | None the data, or None if the key cannot be found/has expired Source code in machine/storage/__init__.py 47 48 49 50 51 52 53 54 55 56 57 58 59 async def get ( self , key : str , shared : bool = False ) -> Any | None : \"\"\"Retrieve data by key :param key: key for the data to retrieve :param shared: ``True/False`` wether to retrieve data from the shared (global) namespace. :return: the data, or ``None`` if the key cannot be found/has expired \"\"\" namespaced_key = self . _namespace_key ( key , shared ) value = await self . _storage . get ( namespaced_key ) if value : return dill . loads ( value ) else : return None has ( key : str , shared : bool = False ) -> bool async Check if the key exists in storage Note: this class implements __contains__ so instead of calling self.storage.has(...) , you can also use: key in self.storage . This will check the namespaced version of the key, so it's the same as: self.storage.has('key', shared=False) Parameters: Name Type Description Default key str key to check required shared bool True/False wether to check in the shared (global) namespace False Returns: Type Description bool True/False wether the key exists. Can only return True if the key has not expired. Source code in machine/storage/__init__.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 async def has ( self , key : str , shared : bool = False ) -> bool : \"\"\"Check if the key exists in storage Note: this class implements ``__contains__`` so instead of calling ``self.storage.has(...)``, you can also use: ``key in self.storage``. This will check the *namespaced* version of the key, so it's the same as: ``self.storage.has('key', shared=False)`` :param key: key to check :param shared: ``True/False`` wether to check in the shared (global) namespace :return: ``True/False`` wether the key exists. Can only return ``True`` if the key has not expired. \"\"\" namespaced_key = self . _namespace_key ( key , shared ) return await self . _storage . has ( namespaced_key ) delete ( key : str , shared : bool = False ) -> None async Remove a key and its data from storage Parameters: Name Type Description Default key str key to remove required shared bool True/False wether the key to remove should be in the shared (global) namespace False Source code in machine/storage/__init__.py 77 78 79 80 81 82 83 84 85 async def delete ( self , key : str , shared : bool = False ) -> None : \"\"\"Remove a key and its data from storage :param key: key to remove :param shared: ``True/False`` wether the key to remove should be in the shared (global) namespace \"\"\" namespaced_key = self . _namespace_key ( key , shared ) await self . _storage . delete ( namespaced_key ) get_storage_size () -> int async Calculate the total size of the storage Returns: Type Description int the total size of the storage in bytes (integer) Source code in machine/storage/__init__.py 87 88 89 90 91 92 async def get_storage_size ( self ) -> int : \"\"\"Calculate the total size of the storage :return: the total size of the storage in bytes (integer) \"\"\" return await self . _storage . size () get_storage_size_human () -> str async Calculate the total size of the storage in human readable format Returns: Type Description str the total size of the storage in a human readable string, rounded to the nearest applicable division. eg. B for Bytes, KiB for Kilobytes, MiB for Megabytes etc. Source code in machine/storage/__init__.py 94 95 96 97 98 99 100 101 async def get_storage_size_human ( self ) -> str : \"\"\"Calculate the total size of the storage in human readable format :return: the total size of the storage in a human readable string, rounded to the nearest applicable division. eg. B for Bytes, KiB for Kilobytes, MiB for Megabytes etc. \"\"\" size = await self . get_storage_size () return sizeof_fmt ( size ) New Storage Backends can be implemented by extending the following class: machine.storage.backends.base.MachineBaseStorage Bases: ABC Base class for storage backends Extending classes should implement the five methods in this base class. Slack Machine takes care of a lot of details regarding the persistent storage of data. So storage backends do not have to deal with the following, because Slack Machine takes care of these: Serialization/Deserialization of data Namespacing of keys (so data stored by different plugins doesn't clash) Source code in machine/storage/backends/base.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 class MachineBaseStorage ( ABC ): \"\"\"Base class for storage backends Extending classes should implement the five methods in this base class. Slack Machine takes care of a lot of details regarding the persistent storage of data. So storage backends **do not** have to deal with the following, because Slack Machine takes care of these: - Serialization/Deserialization of data - Namespacing of keys (so data stored by different plugins doesn't clash) \"\"\" settings : Mapping [ str , Any ] def __init__ ( self , settings : Mapping [ str , Any ]): self . settings = settings async def init ( self ) -> None : \"\"\"Initialize the storage backend\"\"\" pass @abstractmethod async def get ( self , key : str ) -> bytes | None : \"\"\"Retrieve data by key :param key: key for which to retrieve data :return: the raw data for the provided key, as (byte)string. Should return ``None`` when the key is unknown or the data has expired. \"\"\" ... @abstractmethod async def set ( self , key : str , value : bytes , expires : int | None = None ) -> None : \"\"\"Store data by key :param key: the key under which to store the data :param value: data as (byte)string :param expires: optional expiration time in seconds, after which the data should not be returned any more. \"\"\" ... @abstractmethod async def delete ( self , key : str ) -> None : \"\"\"Delete data by key :param key: key for which to delete the data \"\"\" ... @abstractmethod async def has ( self , key : str ) -> bool : \"\"\"Check if the key exists :param key: key to check :return: ``True/False`` wether the key exists \"\"\" ... @abstractmethod async def size ( self ) -> int : \"\"\"Calculate the total size of the storage :return: total size of storage in bytes (integer) \"\"\" ... @abstractmethod async def close ( self ) -> None : \"\"\"Close the storage backend\"\"\" ... init () -> None async Initialize the storage backend Source code in machine/storage/backends/base.py 22 23 24 async def init ( self ) -> None : \"\"\"Initialize the storage backend\"\"\" pass get ( key : str ) -> bytes | None abstractmethod async Retrieve data by key Parameters: Name Type Description Default key str key for which to retrieve data required Returns: Type Description bytes | None the raw data for the provided key, as (byte)string. Should return None when the key is unknown or the data has expired. Source code in machine/storage/backends/base.py 26 27 28 29 30 31 32 33 34 @abstractmethod async def get ( self , key : str ) -> bytes | None : \"\"\"Retrieve data by key :param key: key for which to retrieve data :return: the raw data for the provided key, as (byte)string. Should return ``None`` when the key is unknown or the data has expired. \"\"\" ... set ( key : str , value : bytes , expires : int | None = None ) -> None abstractmethod async Store data by key Parameters: Name Type Description Default key str the key under which to store the data required value bytes data as (byte)string required expires int | None optional expiration time in seconds, after which the data should not be returned any more. None Source code in machine/storage/backends/base.py 36 37 38 39 40 41 42 43 44 45 @abstractmethod async def set ( self , key : str , value : bytes , expires : int | None = None ) -> None : \"\"\"Store data by key :param key: the key under which to store the data :param value: data as (byte)string :param expires: optional expiration time in seconds, after which the data should not be returned any more. \"\"\" ... delete ( key : str ) -> None abstractmethod async Delete data by key Parameters: Name Type Description Default key str key for which to delete the data required Source code in machine/storage/backends/base.py 47 48 49 50 51 52 53 @abstractmethod async def delete ( self , key : str ) -> None : \"\"\"Delete data by key :param key: key for which to delete the data \"\"\" ... has ( key : str ) -> bool abstractmethod async Check if the key exists Parameters: Name Type Description Default key str key to check required Returns: Type Description bool True/False wether the key exists Source code in machine/storage/backends/base.py 55 56 57 58 59 60 61 62 @abstractmethod async def has ( self , key : str ) -> bool : \"\"\"Check if the key exists :param key: key to check :return: ``True/False`` wether the key exists \"\"\" ... size () -> int abstractmethod async Calculate the total size of the storage Returns: Type Description int total size of storage in bytes (integer) Source code in machine/storage/backends/base.py 64 65 66 67 68 69 70 @abstractmethod async def size ( self ) -> int : \"\"\"Calculate the total size of the storage :return: total size of storage in bytes (integer) \"\"\" ... close () -> None abstractmethod async Close the storage backend Source code in machine/storage/backends/base.py 72 73 74 75 @abstractmethod async def close ( self ) -> None : \"\"\"Close the storage backend\"\"\" ...","title":"API Documentation"},{"location":"api/#api-documentation","text":"This is the API documentation of all the classes and functions relevant for Plugin development. The rest of the code deals with the internal workings of Slack Machine and is very much an implementation detail and subject to change. Therefore it is not documented.","title":"API Documentation"},{"location":"api/#plugin-classes","text":"The following 2 classes form the basis for Plugin development.","title":"Plugin classes"},{"location":"api/#machine.plugins.base.MachineBasePlugin","text":"Base class for all Slack Machine plugins The purpose of this class is two-fold: It acts as a marker-class so Slack Machine can recognize plugins as such It provides a lot of common functionality and convenience methods for plugins to interact with channels and users Attributes: Name Type Description settings Slack Machine settings object that contains all settings that were defined through local_settings.py Plugin developers can use any settings that are defined by the user, and ask users to add new settings specifically for their plugin. Source code in machine/plugins/base.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 class MachineBasePlugin : \"\"\"Base class for all Slack Machine plugins The purpose of this class is two-fold: 1. It acts as a marker-class so Slack Machine can recognize plugins as such 2. It provides a lot of common functionality and convenience methods for plugins to interact with channels and users :var settings: Slack Machine settings object that contains all settings that were defined through ``local_settings.py`` Plugin developers can use any settings that are defined by the user, and ask users to add new settings specifically for their plugin. \"\"\" _client : SlackClient storage : PluginStorage settings : CaseInsensitiveDict _fq_name : str def __init__ ( self , client : SlackClient , settings : CaseInsensitiveDict , storage : PluginStorage ): self . _client = client self . storage = storage self . settings = settings self . _fq_name = f \" { self . __module__ } . { self . __class__ . __name__ } \" def init ( self ) -> None : \"\"\"Initialize plugin This method can be implemented by concrete plugin classes. It will be called **once** for each plugin, when that plugin is first loaded. You can refer to settings via ``self.settings``, and access storage through ``self.storage``, but the Slack client has not been initialized yet, so you cannot send or process messages during initialization. :return: None \"\"\" pass @property def users ( self ) -> dict [ str , User ]: \"\"\"Dictionary of all users in the Slack workspace :return: a dictionary of all users in the Slack workspace, where the key is the user id and the value is a [`User`][machine.models.user.User] object \"\"\" return self . _client . users @property def channels ( self ) -> dict [ str , Channel ]: \"\"\"List of all channels in the Slack workspace This is a list of all channels in the Slack workspace that the bot is aware of. This includes all public channels, all private channels the bot is a member of and all DM channels the bot is a member of. :return: a list of all channels in the Slack workspace, where each channel is a :py:class:`~machine.models.channel.Channel` object \"\"\" return self . _client . channels @property def web_client ( self ) -> AsyncWebClient : \"\"\"Slack SDK web client to access the [Slack Web API][slack-web-api] This property references an instance of [`AsyncWebClient`][async-web-client] [slack-web-api]: https://api.slack.com/web [async-web-client]: https://slack.dev/python-slack-sdk/api-docs/slack_sdk/web/async_client.html#slack_sdk.web.async_client.AsyncWebClient # noqa: E501 \"\"\" return self . _client . web_client def find_channel_by_name ( self , channel_name : str ) -> Channel | None : \"\"\"Find a channel by its name, irrespective of a preceding pound symbol. This does not include DMs. :param channel_name: The name of the channel to retrieve. :return: The channel if found, None otherwise. \"\"\" if channel_name . startswith ( \"#\" ): channel_name = channel_name [ 1 :] for c in self . channels . values (): if c . name_normalized and channel_name . lower () == c . name_normalized . lower (): return c return None @property def bot_info ( self ) -> dict [ str , Any ]: \"\"\"Information about the bot user in Slack This will return a dictionary with information about the bot user in Slack that represents Slack Machine :return: Bot user \"\"\" return self . _client . bot_info def at ( self , user : User ) -> str : \"\"\"Create a mention of the provided user Create a mention of the provided user in the form of ``<@[user_id]>``. This method is convenient when you want to include mentions in your message. This method does not send a message, but should be used together with methods like :py:meth:`~machine.plugins.base.MachineBasePlugin.say` :param user: user your want to mention :return: user mention \"\"\" return user . fmt_mention () async def say ( self , channel : Channel | str , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , thread_ts : str | None = None , ephemeral_user : User | str | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Send a message to a channel Send a message to a channel using the WebAPI. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply in-thread and send ephemeral messages, visible to only one user. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral_user`` takes precedence over ``thread_ts`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send message to. Can be public or private (group) channel, or DM channel. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :param ephemeral_user: optional user name or id if the message needs to visible to a specific user only :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral_user` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" return await self . _client . send ( channel , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ephemeral_user = ephemeral_user , ** kwargs , ) async def say_scheduled ( self , when : datetime , channel : Channel | str , text : str , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , thread_ts : str | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Schedule a message to a channel This is the scheduled version of :py:meth:`~machine.plugins.base.MachineBasePlugin.say`. It behaves the same, but will send the message at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send message to. Can be public or private (group) channel, or DM channel. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" return await self . _client . send_scheduled ( when , channel , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ** kwargs , ) async def react ( self , channel : Channel | str , ts : str , emoji : str ) -> AsyncSlackResponse : \"\"\"React to a message in a channel Add a reaction to a message in a channel. What message to react to, is determined by the combination of the channel and the timestamp of the message. :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send message to. Can be public or private (group) channel, or DM channel. :param ts: timestamp of the message to react to :param emoji: what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) :return: Dictionary deserialized from `reactions.add`_ request. .. _reactions.add: https://api.slack.com/methods/reactions.add \"\"\" return await self . _client . react ( channel , ts , emoji ) async def send_dm ( self , user : User | str , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Send a Direct Message Send a Direct Message to a user by opening a DM channel and sending a message to it. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param user: :py:class:`~machine.models.user.User` object or id of user to send DM to. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: Dictionary deserialized from `chat.postMessage`_ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage \"\"\" return await self . _client . send_dm ( user , text , attachments = attachments , blocks = blocks , ** kwargs ) async def send_dm_scheduled ( self , when : datetime , user : User | str , text : str , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Schedule a Direct Message This is the scheduled version of :py:meth:`~machine.plugins.base.MachineBasePlugin.send_dm`. It behaves the same, but will send the DM at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param user: :py:class:`~machine.models.user.User` object or id of user to send DM to. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" return await self . _client . send_dm_scheduled ( when , user , text = text , attachments = attachments , blocks = blocks , ** kwargs ) def emit ( self , event : str , ** kwargs : Any ) -> None : \"\"\"Emit an event Emit an event that plugins can listen for. You can include arbitrary data as keyword arguments. :param event: name of the event :param **kwargs: any data you want to emit with the event :return: None \"\"\" ee . emit ( event , self , ** kwargs ) async def pin_message ( self , channel : Channel | str , ts : str ) -> AsyncSlackResponse : \"\"\"Pin message Pin a message in a channel :param channel: channel to pin the message in :param ts: timestamp of the message to pin :return: response from the Slack Web API \"\"\" return await self . _client . pin_message ( channel , ts ) async def unpin_message ( self , channel : Channel | str , ts : str ) -> AsyncSlackResponse : \"\"\"Unpin message Unpin a message that was previously pinned in a channel :param channel: channel where the message is pinned that needs to be unpinned :param ts: timestamp of the message to unpin :return: response from the Slack Web API \"\"\" return await self . _client . unpin_message ( channel , ts )","title":"MachineBasePlugin"},{"location":"api/#machine.plugins.base.MachineBasePlugin.init","text":"Initialize plugin This method can be implemented by concrete plugin classes. It will be called once for each plugin, when that plugin is first loaded. You can refer to settings via self.settings , and access storage through self.storage , but the Slack client has not been initialized yet, so you cannot send or process messages during initialization. Returns: Type Description None None Source code in machine/plugins/base.py 46 47 48 49 50 51 52 53 54 55 56 def init ( self ) -> None : \"\"\"Initialize plugin This method can be implemented by concrete plugin classes. It will be called **once** for each plugin, when that plugin is first loaded. You can refer to settings via ``self.settings``, and access storage through ``self.storage``, but the Slack client has not been initialized yet, so you cannot send or process messages during initialization. :return: None \"\"\" pass","title":"init()"},{"location":"api/#machine.plugins.base.MachineBasePlugin.users","text":"Dictionary of all users in the Slack workspace Returns: Type Description dict [ str , User ] a dictionary of all users in the Slack workspace, where the key is the user id and the value is a User object Source code in machine/plugins/base.py 58 59 60 61 62 63 64 65 @property def users ( self ) -> dict [ str , User ]: \"\"\"Dictionary of all users in the Slack workspace :return: a dictionary of all users in the Slack workspace, where the key is the user id and the value is a [`User`][machine.models.user.User] object \"\"\" return self . _client . users","title":"users()"},{"location":"api/#machine.plugins.base.MachineBasePlugin.channels","text":"List of all channels in the Slack workspace This is a list of all channels in the Slack workspace that the bot is aware of. This includes all public channels, all private channels the bot is a member of and all DM channels the bot is a member of. Returns: Type Description dict [ str , Channel ] a list of all channels in the Slack workspace, where each channel is a :py:class: ~machine.models.channel.Channel object Source code in machine/plugins/base.py 67 68 69 70 71 72 73 74 75 76 77 78 @property def channels ( self ) -> dict [ str , Channel ]: \"\"\"List of all channels in the Slack workspace This is a list of all channels in the Slack workspace that the bot is aware of. This includes all public channels, all private channels the bot is a member of and all DM channels the bot is a member of. :return: a list of all channels in the Slack workspace, where each channel is a :py:class:`~machine.models.channel.Channel` object \"\"\" return self . _client . channels","title":"channels()"},{"location":"api/#machine.plugins.base.MachineBasePlugin.web_client","text":"Slack SDK web client to access the Slack Web API This property references an instance of AsyncWebClient [async-web-client]: https://slack.dev/python-slack-sdk/api-docs/slack_sdk/web/async_client.html#slack_sdk.web.async_client.AsyncWebClient # noqa: E501 Source code in machine/plugins/base.py 80 81 82 83 84 85 86 87 88 89 @property def web_client ( self ) -> AsyncWebClient : \"\"\"Slack SDK web client to access the [Slack Web API][slack-web-api] This property references an instance of [`AsyncWebClient`][async-web-client] [slack-web-api]: https://api.slack.com/web [async-web-client]: https://slack.dev/python-slack-sdk/api-docs/slack_sdk/web/async_client.html#slack_sdk.web.async_client.AsyncWebClient # noqa: E501 \"\"\" return self . _client . web_client","title":"web_client()"},{"location":"api/#machine.plugins.base.MachineBasePlugin.find_channel_by_name","text":"Find a channel by its name, irrespective of a preceding pound symbol. This does not include DMs. Parameters: Name Type Description Default channel_name str The name of the channel to retrieve. required Returns: Type Description Channel | None The channel if found, None otherwise. Source code in machine/plugins/base.py 91 92 93 94 95 96 97 98 99 100 101 102 def find_channel_by_name ( self , channel_name : str ) -> Channel | None : \"\"\"Find a channel by its name, irrespective of a preceding pound symbol. This does not include DMs. :param channel_name: The name of the channel to retrieve. :return: The channel if found, None otherwise. \"\"\" if channel_name . startswith ( \"#\" ): channel_name = channel_name [ 1 :] for c in self . channels . values (): if c . name_normalized and channel_name . lower () == c . name_normalized . lower (): return c return None","title":"find_channel_by_name()"},{"location":"api/#machine.plugins.base.MachineBasePlugin.bot_info","text":"Information about the bot user in Slack This will return a dictionary with information about the bot user in Slack that represents Slack Machine Returns: Type Description dict [ str , Any ] Bot user Source code in machine/plugins/base.py 104 105 106 107 108 109 110 111 112 113 @property def bot_info ( self ) -> dict [ str , Any ]: \"\"\"Information about the bot user in Slack This will return a dictionary with information about the bot user in Slack that represents Slack Machine :return: Bot user \"\"\" return self . _client . bot_info","title":"bot_info()"},{"location":"api/#machine.plugins.base.MachineBasePlugin.at","text":"Create a mention of the provided user Create a mention of the provided user in the form of <@[user_id]> . This method is convenient when you want to include mentions in your message. This method does not send a message, but should be used together with methods like :py:meth: ~machine.plugins.base.MachineBasePlugin.say Parameters: Name Type Description Default user User user your want to mention required Returns: Type Description str user mention Source code in machine/plugins/base.py 115 116 117 118 119 120 121 122 123 124 125 126 def at ( self , user : User ) -> str : \"\"\"Create a mention of the provided user Create a mention of the provided user in the form of ``<@[user_id]>``. This method is convenient when you want to include mentions in your message. This method does not send a message, but should be used together with methods like :py:meth:`~machine.plugins.base.MachineBasePlugin.say` :param user: user your want to mention :return: user mention \"\"\" return user . fmt_mention ()","title":"at()"},{"location":"api/#machine.plugins.base.MachineBasePlugin.say","text":"Send a message to a channel Send a message to a channel using the WebAPI. Allows for rich formatting using blocks and/or attachments . You can provide blocks and attachments as Python dicts or you can use the convenient classes that the underlying slack client provides. Can also reply in-thread and send ephemeral messages, visible to only one user. Ephemeral messages and threaded messages are mutually exclusive, and ephemeral_user takes precedence over thread_ts Any extra kwargs you provide, will be passed on directly to the chat.postMessage or chat.postEphemeral _ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes Parameters: Name Type Description Default channel Channel | str :py:class: ~machine.models.channel.Channel object or id of channel to send message to. Can be public or private (group) channel, or DM channel. required text str | None message text None attachments Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None optional attachments (see attachments _) None blocks Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None optional blocks (see blocks _) None thread_ts str | None optional timestamp of thread, to send a message in that thread None ephemeral_user User | str | None optional user name or id if the message needs to visible to a specific user only None Returns: Type Description AsyncSlackResponse Dictionary deserialized from chat.postMessage request, or chat.postEphemeral if ephemeral_user is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral Source code in machine/plugins/base.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 async def say ( self , channel : Channel | str , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , thread_ts : str | None = None , ephemeral_user : User | str | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Send a message to a channel Send a message to a channel using the WebAPI. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply in-thread and send ephemeral messages, visible to only one user. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral_user`` takes precedence over ``thread_ts`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send message to. Can be public or private (group) channel, or DM channel. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :param ephemeral_user: optional user name or id if the message needs to visible to a specific user only :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral_user` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" return await self . _client . send ( channel , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ephemeral_user = ephemeral_user , ** kwargs , )","title":"say()"},{"location":"api/#machine.plugins.base.MachineBasePlugin.say_scheduled","text":"Schedule a message to a channel This is the scheduled version of :py:meth: ~machine.plugins.base.MachineBasePlugin.say . It behaves the same, but will send the message at the scheduled time. Parameters: Name Type Description Default when datetime when you want the message to be sent, as :py:class: datetime.datetime instance required channel Channel | str :py:class: ~machine.models.channel.Channel object or id of channel to send message to. Can be public or private (group) channel, or DM channel. required text str message text required attachments Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None optional attachments (see attachments _) None blocks Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None optional blocks (see blocks _) None thread_ts str | None optional timestamp of thread, to send a message in that thread None Returns: Type Description AsyncSlackResponse None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks Source code in machine/plugins/base.py 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 async def say_scheduled ( self , when : datetime , channel : Channel | str , text : str , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , thread_ts : str | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Schedule a message to a channel This is the scheduled version of :py:meth:`~machine.plugins.base.MachineBasePlugin.say`. It behaves the same, but will send the message at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send message to. Can be public or private (group) channel, or DM channel. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" return await self . _client . send_scheduled ( when , channel , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ** kwargs , )","title":"say_scheduled()"},{"location":"api/#machine.plugins.base.MachineBasePlugin.react","text":"React to a message in a channel Add a reaction to a message in a channel. What message to react to, is determined by the combination of the channel and the timestamp of the message. Parameters: Name Type Description Default channel Channel | str :py:class: ~machine.models.channel.Channel object or id of channel to send message to. Can be public or private (group) channel, or DM channel. required ts str timestamp of the message to react to required emoji str what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) required Returns: Type Description AsyncSlackResponse Dictionary deserialized from reactions.add _ request. .. _reactions.add: https://api.slack.com/methods/reactions.add Source code in machine/plugins/base.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 async def react ( self , channel : Channel | str , ts : str , emoji : str ) -> AsyncSlackResponse : \"\"\"React to a message in a channel Add a reaction to a message in a channel. What message to react to, is determined by the combination of the channel and the timestamp of the message. :param channel: :py:class:`~machine.models.channel.Channel` object or id of channel to send message to. Can be public or private (group) channel, or DM channel. :param ts: timestamp of the message to react to :param emoji: what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) :return: Dictionary deserialized from `reactions.add`_ request. .. _reactions.add: https://api.slack.com/methods/reactions.add \"\"\" return await self . _client . react ( channel , ts , emoji )","title":"react()"},{"location":"api/#machine.plugins.base.MachineBasePlugin.send_dm","text":"Send a Direct Message Send a Direct Message to a user by opening a DM channel and sending a message to it. Allows for rich formatting using blocks and/or attachments . You can provide blocks and attachments as Python dicts or you can use the convenient classes that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the chat.postMessage request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes Parameters: Name Type Description Default user User | str :py:class: ~machine.models.user.User object or id of user to send DM to. required text str | None message text None attachments Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None optional attachments (see attachments _) None blocks Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None optional blocks (see blocks _) None Returns: Type Description AsyncSlackResponse Dictionary deserialized from chat.postMessage _ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage Source code in machine/plugins/base.py 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 async def send_dm ( self , user : User | str , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Send a Direct Message Send a Direct Message to a user by opening a DM channel and sending a message to it. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param user: :py:class:`~machine.models.user.User` object or id of user to send DM to. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: Dictionary deserialized from `chat.postMessage`_ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage \"\"\" return await self . _client . send_dm ( user , text , attachments = attachments , blocks = blocks , ** kwargs )","title":"send_dm()"},{"location":"api/#machine.plugins.base.MachineBasePlugin.send_dm_scheduled","text":"Schedule a Direct Message This is the scheduled version of :py:meth: ~machine.plugins.base.MachineBasePlugin.send_dm . It behaves the same, but will send the DM at the scheduled time. Parameters: Name Type Description Default when datetime when you want the message to be sent, as :py:class: datetime.datetime instance required user User | str :py:class: ~machine.models.user.User object or id of user to send DM to. required text str message text required attachments Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None optional attachments (see attachments _) None blocks Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None optional blocks (see blocks _) None Returns: Type Description AsyncSlackResponse None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks Source code in machine/plugins/base.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 async def send_dm_scheduled ( self , when : datetime , user : User | str , text : str , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Schedule a Direct Message This is the scheduled version of :py:meth:`~machine.plugins.base.MachineBasePlugin.send_dm`. It behaves the same, but will send the DM at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param user: :py:class:`~machine.models.user.User` object or id of user to send DM to. :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" return await self . _client . send_dm_scheduled ( when , user , text = text , attachments = attachments , blocks = blocks , ** kwargs )","title":"send_dm_scheduled()"},{"location":"api/#machine.plugins.base.MachineBasePlugin.emit","text":"Emit an event Emit an event that plugins can listen for. You can include arbitrary data as keyword arguments. Parameters: Name Type Description Default event str name of the event required **kwargs Any any data you want to emit with the event {} Returns: Type Description None None Source code in machine/plugins/base.py 291 292 293 294 295 296 297 298 299 300 301 def emit ( self , event : str , ** kwargs : Any ) -> None : \"\"\"Emit an event Emit an event that plugins can listen for. You can include arbitrary data as keyword arguments. :param event: name of the event :param **kwargs: any data you want to emit with the event :return: None \"\"\" ee . emit ( event , self , ** kwargs )","title":"emit()"},{"location":"api/#machine.plugins.base.MachineBasePlugin.pin_message","text":"Pin message Pin a message in a channel Parameters: Name Type Description Default channel Channel | str channel to pin the message in required ts str timestamp of the message to pin required Returns: Type Description AsyncSlackResponse response from the Slack Web API Source code in machine/plugins/base.py 303 304 305 306 307 308 309 310 311 312 async def pin_message ( self , channel : Channel | str , ts : str ) -> AsyncSlackResponse : \"\"\"Pin message Pin a message in a channel :param channel: channel to pin the message in :param ts: timestamp of the message to pin :return: response from the Slack Web API \"\"\" return await self . _client . pin_message ( channel , ts )","title":"pin_message()"},{"location":"api/#machine.plugins.base.MachineBasePlugin.unpin_message","text":"Unpin message Unpin a message that was previously pinned in a channel Parameters: Name Type Description Default channel Channel | str channel where the message is pinned that needs to be unpinned required ts str timestamp of the message to unpin required Returns: Type Description AsyncSlackResponse response from the Slack Web API Source code in machine/plugins/base.py 314 315 316 317 318 319 320 321 322 323 async def unpin_message ( self , channel : Channel | str , ts : str ) -> AsyncSlackResponse : \"\"\"Unpin message Unpin a message that was previously pinned in a channel :param channel: channel where the message is pinned that needs to be unpinned :param ts: timestamp of the message to unpin :return: response from the Slack Web API \"\"\" return await self . _client . unpin_message ( channel , ts )","title":"unpin_message()"},{"location":"api/#machine.plugins.base.Message","text":"A message that was received by the bot This class represents a message that was received by the bot and passed to one or more plugins. It contains the message (text) itself, and metadata about the message, such as the sender of the message, the channel the message was sent to. The Message class also contains convenience methods for replying to the message in the right channel, replying to the sender, etc. Source code in machine/plugins/base.py 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 class Message : \"\"\"A message that was received by the bot This class represents a message that was received by the bot and passed to one or more plugins. It contains the message (text) itself, and metadata about the message, such as the sender of the message, the channel the message was sent to. The ``Message`` class also contains convenience methods for replying to the message in the right channel, replying to the sender, etc. \"\"\" # TODO: create proper class for msg_event def __init__ ( self , client : SlackClient , msg_event : dict [ str , Any ], plugin_class_name : str ): self . _client = client self . _msg_event = msg_event self . _fq_plugin_name = plugin_class_name @property def sender ( self ) -> User : \"\"\"The sender of the message :return: the User the message was sent by \"\"\" return self . _client . users [ self . _msg_event [ \"user\" ]] @property def channel ( self ) -> Channel : \"\"\"The channel the message was sent to :return: the Channel the message was sent to \"\"\" return self . _client . channels [ self . _msg_event [ \"channel\" ]] @property def is_dm ( self ) -> bool : channel_id = self . _msg_event [ \"channel\" ] return not ( channel_id . startswith ( \"C\" ) or channel_id . startswith ( \"G\" )) @property def text ( self ) -> str : \"\"\"The body of the actual message :return: the body (text) of the actual message \"\"\" return self . _msg_event [ \"text\" ] @property def at_sender ( self ) -> str : \"\"\"The sender of the message formatted as mention :return: a string representation of the sender of the message, formatted as `mention`_, to be used in messages .. _mention: https://api.slack.com/docs/message-formatting#linking_to_channels_and_users \"\"\" return self . sender . fmt_mention () async def say ( self , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , thread_ts : str | None = None , ephemeral : bool = False , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Send a new message to the channel the original message was received in Send a new message to the channel the original message was received in, using the WebAPI. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral`` takes precedence over ``thread_ts`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only visible to the sender of the original message :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" if ephemeral : ephemeral_user = self . sender . id else : ephemeral_user = None return await self . _client . send ( self . channel . id , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ephemeral_user = ephemeral_user , ** kwargs , ) async def say_scheduled ( self , when : datetime , text : str , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , thread_ts : str | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Schedule a message This is the scheduled version of :py:meth:`~machine.plugins.base.Message.say`. It behaves the same, but will send the message at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" return await self . _client . send_scheduled ( when , self . channel . id , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ** kwargs , ) async def reply ( self , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , in_thread : bool = False , ephemeral : bool = False , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Reply to the sender of the original message Reply to the sender of the original message with a new message, mentioning that user. Rich formatting using `blocks`_ and/or `attachments`_ is possible. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. In the case of in-thread response, the sender of the original message will not be mentioned. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral`` takes precedence over ``in_thread`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param in_thread: ``True/False`` wether to reply to the original message in-thread :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only visible to the sender of the original message :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" if in_thread and not ephemeral : return await self . say ( text , attachments = attachments , blocks = blocks , thread_ts = self . ts , ** kwargs ) else : text = self . _create_reply ( text ) return await self . say ( text , attachments = attachments , blocks = blocks , ephemeral = ephemeral , ** kwargs ) async def reply_scheduled ( self , when : datetime , text : str , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , in_thread : bool = False , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Schedule a reply and send it This is the scheduled version of :py:meth:`~machine.plugins.base.Message.reply`. It behaves the same, but will send the reply at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param in_thread: ``True/False`` wether to reply to the original message in-thread :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" if in_thread : return await self . say_scheduled ( when , text , attachments = attachments , blocks = blocks , thread_ts = self . ts , ** kwargs ) else : text = cast ( str , self . _create_reply ( text )) return await self . say_scheduled ( when , text , attachments = attachments , blocks = blocks , ** kwargs ) async def reply_dm ( self , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Reply to the sender of the original message with a DM Reply in a Direct Message to the sender of the original message by opening a DM channel and sending a message to it. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: Dictionary deserialized from `chat.postMessage`_ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage \"\"\" return await self . _client . send_dm ( self . sender . id , text , attachments = attachments , blocks = blocks , ** kwargs ) async def reply_dm_scheduled ( self , when : datetime , text : str , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Schedule a DM reply and send it This is the scheduled version of :py:meth:`~machine.plugins.base.Message.reply_dm`. It behaves the same, but will send the DM at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" return await self . _client . send_dm_scheduled ( when , self . sender . id , text = text , attachments = attachments , blocks = blocks , ** kwargs ) async def react ( self , emoji : str ) -> AsyncSlackResponse : \"\"\"React to the original message Add a reaction to the original message :param emoji: what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) :return: Dictionary deserialized from `reactions.add`_ request. .. _reactions.add: https://api.slack.com/methods/reactions.add \"\"\" return await self . _client . react ( self . channel . id , self . _msg_event [ \"ts\" ], emoji ) def _create_reply ( self , text : str | None ) -> str | None : if not self . is_dm and text is not None : return f \" { self . at_sender } : { text } \" else : return text @property def ts ( self ) -> str : \"\"\"The timestamp of the message :return: the timestamp of the message \"\"\" return self . _msg_event [ \"ts\" ] @property def in_thread ( self ) -> bool : \"\"\"Is message in a thread :return: bool \"\"\" return \"thread_ts\" in self . _msg_event async def pin_message ( self ) -> AsyncSlackResponse : \"\"\"Pin message Pin the current message in the channel it was posted in \"\"\" return await self . _client . pin_message ( self . channel , self . ts ) def __str__ ( self ) -> str : if self . channel . is_im : message = f \"Message ' { self . text } ', sent by user @ { self . sender . profile . real_name } in DM\" else : message = ( f \"Message ' { self . text } ', sent by user @ { self . sender . profile . real_name } in channel # { self . channel . name } \" ) return message def __repr__ ( self ) -> str : return f \"Message(text= { self . text !r} , sender= { self . sender . profile . real_name !r} , channel= { self . channel . name !r} )\"","title":"Message"},{"location":"api/#machine.plugins.base.Message.sender","text":"The sender of the message Returns: Type Description User the User the message was sent by Source code in machine/plugins/base.py 343 344 345 346 347 348 349 @property def sender ( self ) -> User : \"\"\"The sender of the message :return: the User the message was sent by \"\"\" return self . _client . users [ self . _msg_event [ \"user\" ]]","title":"sender()"},{"location":"api/#machine.plugins.base.Message.channel","text":"The channel the message was sent to Returns: Type Description Channel the Channel the message was sent to Source code in machine/plugins/base.py 351 352 353 354 355 356 357 @property def channel ( self ) -> Channel : \"\"\"The channel the message was sent to :return: the Channel the message was sent to \"\"\" return self . _client . channels [ self . _msg_event [ \"channel\" ]]","title":"channel()"},{"location":"api/#machine.plugins.base.Message.text","text":"The body of the actual message Returns: Type Description str the body (text) of the actual message Source code in machine/plugins/base.py 364 365 366 367 368 369 370 @property def text ( self ) -> str : \"\"\"The body of the actual message :return: the body (text) of the actual message \"\"\" return self . _msg_event [ \"text\" ]","title":"text()"},{"location":"api/#machine.plugins.base.Message.at_sender","text":"The sender of the message formatted as mention Returns: Type Description str a string representation of the sender of the message, formatted as mention _, to be used in messages .. _mention: https://api.slack.com/docs/message-formatting#linking_to_channels_and_users Source code in machine/plugins/base.py 372 373 374 375 376 377 378 379 380 381 @property def at_sender ( self ) -> str : \"\"\"The sender of the message formatted as mention :return: a string representation of the sender of the message, formatted as `mention`_, to be used in messages .. _mention: https://api.slack.com/docs/message-formatting#linking_to_channels_and_users \"\"\" return self . sender . fmt_mention ()","title":"at_sender()"},{"location":"api/#machine.plugins.base.Message.say","text":"Send a new message to the channel the original message was received in Send a new message to the channel the original message was received in, using the WebAPI. Allows for rich formatting using blocks and/or attachments . You can provide blocks and attachments as Python dicts or you can use the convenient classes that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. Ephemeral messages and threaded messages are mutually exclusive, and ephemeral takes precedence over thread_ts Any extra kwargs you provide, will be passed on directly to the chat.postMessage or chat.postEphemeral _ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes Parameters: Name Type Description Default text str | None message text None attachments Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None optional attachments (see attachments _) None blocks Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None optional blocks (see blocks _) None thread_ts str | None optional timestamp of thread, to send a message in that thread None ephemeral bool True/False wether to send the message as an ephemeral message, only visible to the sender of the original message False Returns: Type Description AsyncSlackResponse Dictionary deserialized from chat.postMessage request, or chat.postEphemeral if ephemeral is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral Source code in machine/plugins/base.py 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 async def say ( self , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , thread_ts : str | None = None , ephemeral : bool = False , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Send a new message to the channel the original message was received in Send a new message to the channel the original message was received in, using the WebAPI. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral`` takes precedence over ``thread_ts`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only visible to the sender of the original message :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" if ephemeral : ephemeral_user = self . sender . id else : ephemeral_user = None return await self . _client . send ( self . channel . id , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ephemeral_user = ephemeral_user , ** kwargs , )","title":"say()"},{"location":"api/#machine.plugins.base.Message.say_scheduled","text":"Schedule a message This is the scheduled version of :py:meth: ~machine.plugins.base.Message.say . It behaves the same, but will send the message at the scheduled time. Parameters: Name Type Description Default when datetime when you want the message to be sent, as :py:class: datetime.datetime instance required text str message text required attachments Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None optional attachments (see attachments _) None blocks Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None optional blocks (see blocks _) None thread_ts str | None optional timestamp of thread, to send a message in that thread None Returns: Type Description AsyncSlackResponse None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks Source code in machine/plugins/base.py 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 async def say_scheduled ( self , when : datetime , text : str , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , thread_ts : str | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Schedule a message This is the scheduled version of :py:meth:`~machine.plugins.base.Message.say`. It behaves the same, but will send the message at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param thread_ts: optional timestamp of thread, to send a message in that thread :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" return await self . _client . send_scheduled ( when , self . channel . id , text = text , attachments = attachments , blocks = blocks , thread_ts = thread_ts , ** kwargs , )","title":"say_scheduled()"},{"location":"api/#machine.plugins.base.Message.reply","text":"Reply to the sender of the original message Reply to the sender of the original message with a new message, mentioning that user. Rich formatting using blocks and/or attachments is possible. You can provide blocks and attachments as Python dicts or you can use the convenient classes that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. In the case of in-thread response, the sender of the original message will not be mentioned. Ephemeral messages and threaded messages are mutually exclusive, and ephemeral takes precedence over in_thread Any extra kwargs you provide, will be passed on directly to the chat.postMessage or chat.postEphemeral _ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes Parameters: Name Type Description Default text str | None message text None attachments Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None optional attachments (see attachments _) None blocks Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None optional blocks (see blocks _) None in_thread bool True/False wether to reply to the original message in-thread False ephemeral bool True/False wether to send the message as an ephemeral message, only visible to the sender of the original message False Returns: Type Description AsyncSlackResponse Dictionary deserialized from chat.postMessage request, or chat.postEphemeral if ephemeral is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral Source code in machine/plugins/base.py 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 async def reply ( self , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , in_thread : bool = False , ephemeral : bool = False , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Reply to the sender of the original message Reply to the sender of the original message with a new message, mentioning that user. Rich formatting using `blocks`_ and/or `attachments`_ is possible. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Can also reply to a thread and send an ephemeral message only visible to the sender of the original message. In the case of in-thread response, the sender of the original message will not be mentioned. Ephemeral messages and threaded messages are mutually exclusive, and ``ephemeral`` takes precedence over ``in_thread`` Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ or `chat.postEphemeral`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param in_thread: ``True/False`` wether to reply to the original message in-thread :param ephemeral: ``True/False`` wether to send the message as an ephemeral message, only visible to the sender of the original message :return: Dictionary deserialized from `chat.postMessage`_ request, or `chat.postEphemeral`_ if `ephemeral` is True. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage .. _chat.postEphemeral: https://api.slack.com/methods/chat.postEphemeral \"\"\" if in_thread and not ephemeral : return await self . say ( text , attachments = attachments , blocks = blocks , thread_ts = self . ts , ** kwargs ) else : text = self . _create_reply ( text ) return await self . say ( text , attachments = attachments , blocks = blocks , ephemeral = ephemeral , ** kwargs )","title":"reply()"},{"location":"api/#machine.plugins.base.Message.reply_scheduled","text":"Schedule a reply and send it This is the scheduled version of :py:meth: ~machine.plugins.base.Message.reply . It behaves the same, but will send the reply at the scheduled time. Parameters: Name Type Description Default when datetime when you want the message to be sent, as :py:class: datetime.datetime instance required text str message text required attachments Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None optional attachments (see attachments _) None blocks Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None optional blocks (see blocks _) None in_thread bool True/False wether to reply to the original message in-thread False Returns: Type Description AsyncSlackResponse None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks Source code in machine/plugins/base.py 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 async def reply_scheduled ( self , when : datetime , text : str , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , in_thread : bool = False , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Schedule a reply and send it This is the scheduled version of :py:meth:`~machine.plugins.base.Message.reply`. It behaves the same, but will send the reply at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :param in_thread: ``True/False`` wether to reply to the original message in-thread :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" if in_thread : return await self . say_scheduled ( when , text , attachments = attachments , blocks = blocks , thread_ts = self . ts , ** kwargs ) else : text = cast ( str , self . _create_reply ( text )) return await self . say_scheduled ( when , text , attachments = attachments , blocks = blocks , ** kwargs )","title":"reply_scheduled()"},{"location":"api/#machine.plugins.base.Message.reply_dm","text":"Reply to the sender of the original message with a DM Reply in a Direct Message to the sender of the original message by opening a DM channel and sending a message to it. Allows for rich formatting using blocks and/or attachments . You can provide blocks and attachments as Python dicts or you can use the convenient classes that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the chat.postMessage request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes Parameters: Name Type Description Default text str | None message text None attachments Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None optional attachments (see attachments _) None blocks Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None optional blocks (see blocks _) None Returns: Type Description AsyncSlackResponse Dictionary deserialized from chat.postMessage _ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage Source code in machine/plugins/base.py 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 async def reply_dm ( self , text : str | None = None , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Reply to the sender of the original message with a DM Reply in a Direct Message to the sender of the original message by opening a DM channel and sending a message to it. Allows for rich formatting using `blocks`_ and/or `attachments`_. You can provide blocks and attachments as Python dicts or you can use the `convenient classes`_ that the underlying slack client provides. Any extra kwargs you provide, will be passed on directly to the `chat.postMessage`_ request. .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks .. _convenient classes: https://github.com/slackapi/python-slackclient/tree/master/slack/web/classes :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: Dictionary deserialized from `chat.postMessage`_ request. .. _chat.postMessage: https://api.slack.com/methods/chat.postMessage \"\"\" return await self . _client . send_dm ( self . sender . id , text , attachments = attachments , blocks = blocks , ** kwargs )","title":"reply_dm()"},{"location":"api/#machine.plugins.base.Message.reply_dm_scheduled","text":"Schedule a DM reply and send it This is the scheduled version of :py:meth: ~machine.plugins.base.Message.reply_dm . It behaves the same, but will send the DM at the scheduled time. Parameters: Name Type Description Default when datetime when you want the message to be sent, as :py:class: datetime.datetime instance required text str message text required attachments Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None optional attachments (see attachments _) None blocks Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None optional blocks (see blocks _) None Returns: Type Description AsyncSlackResponse None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks Source code in machine/plugins/base.py 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 async def reply_dm_scheduled ( self , when : datetime , text : str , attachments : Sequence [ Attachment ] | Sequence [ dict [ str , Any ]] | None = None , blocks : Sequence [ Block ] | Sequence [ dict [ str , Any ]] | None = None , ** kwargs : Any , ) -> AsyncSlackResponse : \"\"\"Schedule a DM reply and send it This is the scheduled version of :py:meth:`~machine.plugins.base.Message.reply_dm`. It behaves the same, but will send the DM at the scheduled time. :param when: when you want the message to be sent, as :py:class:`datetime.datetime` instance :param text: message text :param attachments: optional attachments (see `attachments`_) :param blocks: optional blocks (see `blocks`_) :return: None .. _attachments: https://api.slack.com/docs/message-attachments .. _blocks: https://api.slack.com/reference/block-kit/blocks \"\"\" return await self . _client . send_dm_scheduled ( when , self . sender . id , text = text , attachments = attachments , blocks = blocks , ** kwargs )","title":"reply_dm_scheduled()"},{"location":"api/#machine.plugins.base.Message.react","text":"React to the original message Add a reaction to the original message Parameters: Name Type Description Default emoji str what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) required Returns: Type Description AsyncSlackResponse Dictionary deserialized from reactions.add _ request. .. _reactions.add: https://api.slack.com/methods/reactions.add Source code in machine/plugins/base.py 602 603 604 605 606 607 608 609 610 611 612 async def react ( self , emoji : str ) -> AsyncSlackResponse : \"\"\"React to the original message Add a reaction to the original message :param emoji: what emoji to react with (should be a string, like 'angel', 'thumbsup', etc.) :return: Dictionary deserialized from `reactions.add`_ request. .. _reactions.add: https://api.slack.com/methods/reactions.add \"\"\" return await self . _client . react ( self . channel . id , self . _msg_event [ \"ts\" ], emoji )","title":"react()"},{"location":"api/#machine.plugins.base.Message.ts","text":"The timestamp of the message Returns: Type Description str the timestamp of the message Source code in machine/plugins/base.py 620 621 622 623 624 625 626 @property def ts ( self ) -> str : \"\"\"The timestamp of the message :return: the timestamp of the message \"\"\" return self . _msg_event [ \"ts\" ]","title":"ts()"},{"location":"api/#machine.plugins.base.Message.in_thread","text":"Is message in a thread Returns: Type Description bool bool Source code in machine/plugins/base.py 628 629 630 631 632 633 634 @property def in_thread ( self ) -> bool : \"\"\"Is message in a thread :return: bool \"\"\" return \"thread_ts\" in self . _msg_event","title":"in_thread()"},{"location":"api/#machine.plugins.base.Message.pin_message","text":"Pin message Pin the current message in the channel it was posted in Source code in machine/plugins/base.py 636 637 638 639 640 641 async def pin_message ( self ) -> AsyncSlackResponse : \"\"\"Pin message Pin the current message in the channel it was posted in \"\"\" return await self . _client . pin_message ( self . channel , self . ts )","title":"pin_message()"},{"location":"api/#decorators","text":"These are the decorators you can use to have Slack Machine respond to specific things (events, messages, etc.)","title":"Decorators"},{"location":"api/#machine.plugins.decorators","text":"","title":"decorators"},{"location":"api/#machine.plugins.decorators.process","text":"Process Slack events of a specific type This decorator will enable a Plugin method to process Slack events _ of a specific type. The Plugin method will be called for each event of the specified type that the bot receives. The received event will be passed to the method when called. .. _Slack events: https://api.slack.com/events Parameters: Name Type Description Default slack_event_type str type of event the method needs to process. Can be any event supported by the RTM API required Returns: Type Description Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]] wrapped method Source code in machine/plugins/decorators.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def process ( slack_event_type : str ) -> Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]]: \"\"\"Process Slack events of a specific type This decorator will enable a Plugin method to process `Slack events`_ of a specific type. The Plugin method will be called for each event of the specified type that the bot receives. The received event will be passed to the method when called. .. _Slack events: https://api.slack.com/events :param slack_event_type: type of event the method needs to process. Can be any event supported by the RTM API :return: wrapped method \"\"\" def process_decorator ( f : Callable [ P , R ]) -> DecoratedPluginFunc [ P , R ]: fn = cast ( DecoratedPluginFunc , f ) fn . metadata = getattr ( f , \"metadata\" , Metadata ()) fn . metadata . plugin_actions . process . append ( slack_event_type ) return fn return process_decorator","title":"process()"},{"location":"api/#machine.plugins.decorators.listen_to","text":"Listen to messages matching a regex pattern This decorator will enable a Plugin method to listen to messages that match a regex pattern. The Plugin method will be called for each message that matches the specified regex pattern. The received :py:class: ~machine.plugins.base.Message will be passed to the method when called. Named groups can be used in the regex pattern, to catch specific parts of the message. These groups will be passed to the method as keyword arguments when called. Parameters: Name Type Description Default regex str regex pattern to listen for required flags re . RegexFlag | int regex flags to apply when matching re.IGNORECASE handle_message_changed bool if changed messages should trigger the decorated function False Returns: Type Description Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]] wrapped method Source code in machine/plugins/decorators.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def listen_to ( regex : str , flags : re . RegexFlag | int = re . IGNORECASE , handle_message_changed : bool = False ) -> Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]]: \"\"\"Listen to messages matching a regex pattern This decorator will enable a Plugin method to listen to messages that match a regex pattern. The Plugin method will be called for each message that matches the specified regex pattern. The received :py:class:`~machine.plugins.base.Message` will be passed to the method when called. Named groups can be used in the regex pattern, to catch specific parts of the message. These groups will be passed to the method as keyword arguments when called. :param regex: regex pattern to listen for :param flags: regex flags to apply when matching :param handle_message_changed: if changed messages should trigger the decorated function :return: wrapped method \"\"\" def listen_to_decorator ( f : Callable [ P , R ]) -> DecoratedPluginFunc [ P , R ]: fn = cast ( DecoratedPluginFunc , f ) fn . metadata = getattr ( f , \"metadata\" , Metadata ()) fn . metadata . plugin_actions . listen_to . append ( MatcherConfig ( re . compile ( regex , flags ), handle_message_changed )) return fn return listen_to_decorator","title":"listen_to()"},{"location":"api/#machine.plugins.decorators.respond_to","text":"Listen to messages mentioning the bot and matching a regex pattern This decorator will enable a Plugin method to listen to messages that are directed to the bot (ie. message starts by mentioning the bot) and match a regex pattern. The Plugin method will be called for each message that mentions the bot and matches the specified regex pattern. The received :py:class: ~machine.plugins.base.Message will be passed to the method when called. Named groups can be used in the regex pattern, to catch specific parts of the message. These groups will be passed to the method as keyword arguments when called. Parameters: Name Type Description Default regex str regex pattern to listen for required flags re . RegexFlag | int regex flags to apply when matching re.IGNORECASE handle_message_changed bool if changed messages should trigger the decorated function False Returns: Type Description Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]] wrapped method Source code in machine/plugins/decorators.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def respond_to ( regex : str , flags : re . RegexFlag | int = re . IGNORECASE , handle_message_changed : bool = False ) -> Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]]: \"\"\"Listen to messages mentioning the bot and matching a regex pattern This decorator will enable a Plugin method to listen to messages that are directed to the bot (ie. message starts by mentioning the bot) and match a regex pattern. The Plugin method will be called for each message that mentions the bot and matches the specified regex pattern. The received :py:class:`~machine.plugins.base.Message` will be passed to the method when called. Named groups can be used in the regex pattern, to catch specific parts of the message. These groups will be passed to the method as keyword arguments when called. :param regex: regex pattern to listen for :param flags: regex flags to apply when matching :param handle_message_changed: if changed messages should trigger the decorated function :return: wrapped method \"\"\" def respond_to_decorator ( f : Callable [ P , R ]) -> DecoratedPluginFunc [ P , R ]: fn = cast ( DecoratedPluginFunc , f ) fn . metadata = getattr ( f , \"metadata\" , Metadata ()) fn . metadata . plugin_actions . respond_to . append ( MatcherConfig ( re . compile ( regex , flags ), handle_message_changed )) return fn return respond_to_decorator","title":"respond_to()"},{"location":"api/#machine.plugins.decorators.schedule","text":"Schedule a function to be executed according to a crontab-like schedule The decorated function will be executed according to the schedule provided. Slack Machine uses APScheduler under the hood for scheduling. For more information on the interpretation of the provided parameters, see :class: CronTrigger<apscheduler:apscheduler.triggers.cron.CronTrigger> Parameters: Name Type Description Default year int|str 4-digit year None month int|str month (1-12) None day int|str day of the (1-31) None week int|str ISO week (1-53) None day_of_week int|str number or name of weekday (0-6 or mon,tue,wed,thu,fri,sat,sun) None hour int|str hour (0-23) None minute int|str minute (0-59) None second int|str second (0-59) None start_date datetime|str earliest possible date/time to trigger on (inclusive) None end_date datetime|str latest possible date/time to trigger on (inclusive) None timezone datetime.tzinfo|str time zone to use for the date/time calculations (defaults to scheduler timezone) None Source code in machine/plugins/decorators.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def schedule ( year : int | str | None = None , month : int | str | None = None , day : int | str | None = None , week : int | str | None = None , day_of_week : int | str | None = None , hour : int | str | None = None , minute : int | str | None = None , second : int | str | None = None , start_date : datetime | str | None = None , end_date : datetime | str | None = None , timezone : tzinfo | str | None = None , ) -> Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]]: \"\"\"Schedule a function to be executed according to a crontab-like schedule The decorated function will be executed according to the schedule provided. Slack Machine uses APScheduler under the hood for scheduling. For more information on the interpretation of the provided parameters, see :class:`CronTrigger<apscheduler:apscheduler.triggers.cron.CronTrigger>` :param int|str year: 4-digit year :param int|str month: month (1-12) :param int|str day: day of the (1-31) :param int|str week: ISO week (1-53) :param int|str day_of_week: number or name of weekday (0-6 or mon,tue,wed,thu,fri,sat,sun) :param int|str hour: hour (0-23) :param int|str minute: minute (0-59) :param int|str second: second (0-59) :param datetime|str start_date: earliest possible date/time to trigger on (inclusive) :param datetime|str end_date: latest possible date/time to trigger on (inclusive) :param datetime.tzinfo|str timezone: time zone to use for the date/time calculations (defaults to scheduler timezone) \"\"\" kwargs = locals () def schedule_decorator ( f : Callable [ P , R ]) -> DecoratedPluginFunc [ P , R ]: fn = cast ( DecoratedPluginFunc , f ) fn . metadata = getattr ( f , \"metadata\" , Metadata ()) fn . metadata . plugin_actions . schedule = kwargs return fn return schedule_decorator","title":"schedule()"},{"location":"api/#machine.plugins.decorators.on","text":"Listen for an event The decorated function will be called whenever a plugin (or Slack Machine itself) emits an event with the given name. Parameters: Name Type Description Default event str name of the event to listen for. Event names are global required Source code in machine/plugins/decorators.py 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def on ( event : str ) -> Callable [[ Callable [ P , R ]], Callable [ P , R ]]: \"\"\"Listen for an event The decorated function will be called whenever a plugin (or Slack Machine itself) emits an event with the given name. :param event: name of the event to listen for. Event names are global \"\"\" def on_decorator ( f : Callable [ P , R ]) -> Callable [ P , R ]: ee . add_listener ( event , f ) return f return on_decorator","title":"on()"},{"location":"api/#machine.plugins.decorators.required_settings","text":"Specify a required setting for a plugin or plugin method The settings specified with this decorator will be added to the required settings for the plugin. If one or more settings have not been defined by the user, the plugin will not be loaded and a warning will be written to the console upon startup. Parameters: Name Type Description Default settings list [ str ] | str settings that are required (can be list of strings, or single string) required Source code in machine/plugins/decorators.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 def required_settings ( settings : list [ str ] | str ) -> Callable [[ Callable [ P , R ]], DecoratedPluginFunc [ P , R ]]: \"\"\"Specify a required setting for a plugin or plugin method The settings specified with this decorator will be added to the required settings for the plugin. If one or more settings have not been defined by the user, the plugin will not be loaded and a warning will be written to the console upon startup. :param settings: settings that are required (can be list of strings, or single string) \"\"\" def required_settings_decorator ( f_or_cls : Callable [ P , R ]) -> DecoratedPluginFunc [ P , R ]: casted_f_or_cls = cast ( DecoratedPluginFunc , f_or_cls ) casted_f_or_cls . metadata = getattr ( f_or_cls , \"metadata\" , Metadata ()) if isinstance ( settings , list ): casted_f_or_cls . metadata . required_settings . extend ( settings ) elif isinstance ( settings , str ): casted_f_or_cls . metadata . required_settings . append ( settings ) return casted_f_or_cls return required_settings_decorator","title":"required_settings()"},{"location":"api/#machine.plugins.decorators.require_any_role","text":"Specify required roles for a plugin method To use the plugin method where this decorator is applied, the user must have at least one of the listed roles. Parameters: Name Type Description Default required_roles list [ str ] list of roles required to use the plugin method required Source code in machine/plugins/decorators.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 def require_any_role ( required_roles : list [ str ], ) -> Callable [[ Callable [ ... , Awaitable [ None ]]], Callable [ ... , Awaitable [ None ]]]: \"\"\"Specify required roles for a plugin method To use the plugin method where this decorator is applied, the user must have at least one of the listed roles. :param required_roles: list of roles required to use the plugin method \"\"\" def middle ( func : Callable [ ... , Awaitable [ None ]]) -> Callable [ ... , Awaitable [ None ]]: async def wrapper ( self : MachineBasePlugin , msg : Message , ** kwargs : Any ) -> None : if await matching_roles_by_user_id ( self , msg . sender . id , required_roles ): logger . debug ( f \"User { msg . sender } has one of the required roles { required_roles } \" ) return await func ( self , msg , ** kwargs ) else : logger . debug ( f \"User { msg . sender } does not have any of the required roles { required_roles } \" ) ee . emit ( \"unauthorized-access\" , self , message = msg , required_roles = required_roles , combinator = RoleCombinator . ANY , ) await msg . say ( \"I'm sorry, but you don't have access to that command\" , ephemeral = True ) return None # Copy any existing docs and metadata from container function to # generated function wrapper . __doc__ = func . __doc__ casted_wrapper = cast ( DecoratedPluginFunc , wrapper ) casted_wrapper . metadata = getattr ( func , \"metadata\" , Metadata ()) return casted_wrapper return middle","title":"require_any_role()"},{"location":"api/#machine.plugins.decorators.require_all_roles","text":"Specify required roles for a plugin method To use the plugin method where this decorator is applied, the user must have all of the listed roles. Parameters: Name Type Description Default required_roles list [ str ] list of roles required to use the plugin method required Source code in machine/plugins/decorators.py 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 def require_all_roles ( required_roles : list [ str ], ) -> Callable [[ Callable [ ... , Awaitable [ None ]]], Callable [ ... , Awaitable [ None ]]]: \"\"\"Specify required roles for a plugin method To use the plugin method where this decorator is applied, the user must have all of the listed roles. :param required_roles: list of roles required to use the plugin method \"\"\" def middle ( func : Callable [ ... , Awaitable [ None ]]) -> Callable [ ... , Awaitable [ None ]]: async def wrapper ( self : MachineBasePlugin , msg : Message , ** kwargs : Any ) -> None : if await matching_roles_by_user_id ( self , msg . sender . id , required_roles ) == len ( required_roles ): logger . debug ( f \"User { msg . sender } has all of the required roles { required_roles } \" ) return await func ( self , msg , ** kwargs ) else : logger . debug ( f \"User { msg . sender } does not have all of the required roles { required_roles } \" ) ee . emit ( \"unauthorized-access\" , self , message = msg , required_roles = required_roles , combinator = RoleCombinator . ALL , ) await msg . say ( \"I'm sorry, but you don't have access to that command\" , ephemeral = True ) return None # Copy any existing docs and metadata from container function to # generated function wrapper . __doc__ = func . __doc__ casted_wrapper = cast ( DecoratedPluginFunc , wrapper ) casted_wrapper . metadata = getattr ( func , \"metadata\" , Metadata ()) return casted_wrapper return middle","title":"require_all_roles()"},{"location":"api/#models","text":"These classes represent base objects from the Slack API","title":"Models"},{"location":"api/#machine.models.user.User","text":"Bases: BaseModel User model that represents a user object from the Slack API Source code in machine/models/user.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class User ( BaseModel ): \"\"\" User model that represents a user object from the Slack API \"\"\" id : str team_id : Optional [ str ] name : str deleted : Optional [ bool ] profile : Profile is_bot : bool updated : int is_app_user : bool color : Optional [ str ] = None real_name : Optional [ str ] = None tz : Optional [ str ] = None tz_label : Optional [ str ] = None tz_offset : Optional [ int ] = None is_admin : Optional [ bool ] = None is_owner : Optional [ bool ] = None is_primary_owner : Optional [ bool ] = None is_restricted : Optional [ bool ] = None is_ultra_restricted : Optional [ bool ] = None is_stranger : Optional [ bool ] = None has_2fa : Optional [ bool ] = None locale : Optional [ str ] = None class Config : allow_mutation = False def fmt_mention ( self ) -> str : return f \"<@ { self . id } >\"","title":"User"},{"location":"api/#machine.models.channel.Channel","text":"Bases: BaseModel Channel model that represents a channel object from the Slack API Source code in machine/models/channel.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class Channel ( BaseModel ): \"\"\" Channel model that represents a channel object from the Slack API \"\"\" id : str name : Optional [ str ] created : int creator : Optional [ str ] is_archived : bool is_general : Optional [ bool ] name_normalized : Optional [ str ] is_shared : Optional [ bool ] is_org_shared : bool is_member : Optional [ bool ] is_private : Optional [ bool ] is_mpim : Optional [ bool ] is_channel : Optional [ bool ] is_group : Optional [ bool ] is_im : Optional [ bool ] user : Optional [ str ] topic : Optional [ PurposeTopic ] purpose : Optional [ PurposeTopic ] previous_names : Optional [ List [ str ]] @property def identifier ( self ) -> str : if self . name : return self . name else : return self . id class Config : allow_mutation = False","title":"Channel"},{"location":"api/#storage","text":"Storage is exposed to plugins through the self.storage field. The following class implements the interface plugins can use to interact with the storage backend.","title":"Storage"},{"location":"api/#machine.storage.PluginStorage","text":"Class providing access to persistent storage for plugins This class is the main access point for plugins to work with persistent storage. It is accessible from plugins using self.storage . Data is serialized before sending it to the storage backend, and deserialized upon retrieval. Serialization is done by dill _, so pretty much any Python object can be stored and retrieved. .. _Dill: https://pypi.python.org/pypi/dill Source code in machine/storage/__init__.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 class PluginStorage : \"\"\"Class providing access to persistent storage for plugins This class is the main access point for plugins to work with persistent storage. It is accessible from plugins using ``self.storage``. Data is serialized before sending it to the storage backend, and deserialized upon retrieval. Serialization is done by `dill`_, so pretty much any Python object can be stored and retrieved. .. _Dill: https://pypi.python.org/pypi/dill \"\"\" def __init__ ( self , fq_plugin_name : str , storage_backend : MachineBaseStorage ): self . _fq_plugin_name = fq_plugin_name self . _storage = storage_backend def _gen_unique_key ( self , key : str ) -> str : return f \" { self . _fq_plugin_name } : { key } \" def _namespace_key ( self , key : str , shared : bool = False ) -> str : return key if shared else self . _gen_unique_key ( key ) async def set ( self , key : str , value : Any , expires : int | timedelta | None = None , shared : bool = False ) -> None : \"\"\"Store or update a value by key :param key: the key under which to store the data :param value: the data to store :param expires: optional number of seconds after which the data is expired :param shared: ``True/False`` wether this data should be shared by other plugins. Use with care, because it pollutes the global namespace of the storage. \"\"\" expires = int ( expires . total_seconds ()) if isinstance ( expires , timedelta ) else expires namespaced_key = self . _namespace_key ( key , shared ) pickled_value = dill . dumps ( value ) await self . _storage . set ( namespaced_key , pickled_value , expires ) async def get ( self , key : str , shared : bool = False ) -> Any | None : \"\"\"Retrieve data by key :param key: key for the data to retrieve :param shared: ``True/False`` wether to retrieve data from the shared (global) namespace. :return: the data, or ``None`` if the key cannot be found/has expired \"\"\" namespaced_key = self . _namespace_key ( key , shared ) value = await self . _storage . get ( namespaced_key ) if value : return dill . loads ( value ) else : return None async def has ( self , key : str , shared : bool = False ) -> bool : \"\"\"Check if the key exists in storage Note: this class implements ``__contains__`` so instead of calling ``self.storage.has(...)``, you can also use: ``key in self.storage``. This will check the *namespaced* version of the key, so it's the same as: ``self.storage.has('key', shared=False)`` :param key: key to check :param shared: ``True/False`` wether to check in the shared (global) namespace :return: ``True/False`` wether the key exists. Can only return ``True`` if the key has not expired. \"\"\" namespaced_key = self . _namespace_key ( key , shared ) return await self . _storage . has ( namespaced_key ) async def delete ( self , key : str , shared : bool = False ) -> None : \"\"\"Remove a key and its data from storage :param key: key to remove :param shared: ``True/False`` wether the key to remove should be in the shared (global) namespace \"\"\" namespaced_key = self . _namespace_key ( key , shared ) await self . _storage . delete ( namespaced_key ) async def get_storage_size ( self ) -> int : \"\"\"Calculate the total size of the storage :return: the total size of the storage in bytes (integer) \"\"\" return await self . _storage . size () async def get_storage_size_human ( self ) -> str : \"\"\"Calculate the total size of the storage in human readable format :return: the total size of the storage in a human readable string, rounded to the nearest applicable division. eg. B for Bytes, KiB for Kilobytes, MiB for Megabytes etc. \"\"\" size = await self . get_storage_size () return sizeof_fmt ( size )","title":"PluginStorage"},{"location":"api/#machine.storage.PluginStorage.set","text":"Store or update a value by key Parameters: Name Type Description Default key str the key under which to store the data required value Any the data to store required expires int | timedelta | None optional number of seconds after which the data is expired None shared bool True/False wether this data should be shared by other plugins. Use with care, because it pollutes the global namespace of the storage. False Source code in machine/storage/__init__.py 33 34 35 36 37 38 39 40 41 42 43 44 45 async def set ( self , key : str , value : Any , expires : int | timedelta | None = None , shared : bool = False ) -> None : \"\"\"Store or update a value by key :param key: the key under which to store the data :param value: the data to store :param expires: optional number of seconds after which the data is expired :param shared: ``True/False`` wether this data should be shared by other plugins. Use with care, because it pollutes the global namespace of the storage. \"\"\" expires = int ( expires . total_seconds ()) if isinstance ( expires , timedelta ) else expires namespaced_key = self . _namespace_key ( key , shared ) pickled_value = dill . dumps ( value ) await self . _storage . set ( namespaced_key , pickled_value , expires )","title":"set()"},{"location":"api/#machine.storage.PluginStorage.get","text":"Retrieve data by key Parameters: Name Type Description Default key str key for the data to retrieve required shared bool True/False wether to retrieve data from the shared (global) namespace. False Returns: Type Description Any | None the data, or None if the key cannot be found/has expired Source code in machine/storage/__init__.py 47 48 49 50 51 52 53 54 55 56 57 58 59 async def get ( self , key : str , shared : bool = False ) -> Any | None : \"\"\"Retrieve data by key :param key: key for the data to retrieve :param shared: ``True/False`` wether to retrieve data from the shared (global) namespace. :return: the data, or ``None`` if the key cannot be found/has expired \"\"\" namespaced_key = self . _namespace_key ( key , shared ) value = await self . _storage . get ( namespaced_key ) if value : return dill . loads ( value ) else : return None","title":"get()"},{"location":"api/#machine.storage.PluginStorage.has","text":"Check if the key exists in storage Note: this class implements __contains__ so instead of calling self.storage.has(...) , you can also use: key in self.storage . This will check the namespaced version of the key, so it's the same as: self.storage.has('key', shared=False) Parameters: Name Type Description Default key str key to check required shared bool True/False wether to check in the shared (global) namespace False Returns: Type Description bool True/False wether the key exists. Can only return True if the key has not expired. Source code in machine/storage/__init__.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 async def has ( self , key : str , shared : bool = False ) -> bool : \"\"\"Check if the key exists in storage Note: this class implements ``__contains__`` so instead of calling ``self.storage.has(...)``, you can also use: ``key in self.storage``. This will check the *namespaced* version of the key, so it's the same as: ``self.storage.has('key', shared=False)`` :param key: key to check :param shared: ``True/False`` wether to check in the shared (global) namespace :return: ``True/False`` wether the key exists. Can only return ``True`` if the key has not expired. \"\"\" namespaced_key = self . _namespace_key ( key , shared ) return await self . _storage . has ( namespaced_key )","title":"has()"},{"location":"api/#machine.storage.PluginStorage.delete","text":"Remove a key and its data from storage Parameters: Name Type Description Default key str key to remove required shared bool True/False wether the key to remove should be in the shared (global) namespace False Source code in machine/storage/__init__.py 77 78 79 80 81 82 83 84 85 async def delete ( self , key : str , shared : bool = False ) -> None : \"\"\"Remove a key and its data from storage :param key: key to remove :param shared: ``True/False`` wether the key to remove should be in the shared (global) namespace \"\"\" namespaced_key = self . _namespace_key ( key , shared ) await self . _storage . delete ( namespaced_key )","title":"delete()"},{"location":"api/#machine.storage.PluginStorage.get_storage_size","text":"Calculate the total size of the storage Returns: Type Description int the total size of the storage in bytes (integer) Source code in machine/storage/__init__.py 87 88 89 90 91 92 async def get_storage_size ( self ) -> int : \"\"\"Calculate the total size of the storage :return: the total size of the storage in bytes (integer) \"\"\" return await self . _storage . size ()","title":"get_storage_size()"},{"location":"api/#machine.storage.PluginStorage.get_storage_size_human","text":"Calculate the total size of the storage in human readable format Returns: Type Description str the total size of the storage in a human readable string, rounded to the nearest applicable division. eg. B for Bytes, KiB for Kilobytes, MiB for Megabytes etc. Source code in machine/storage/__init__.py 94 95 96 97 98 99 100 101 async def get_storage_size_human ( self ) -> str : \"\"\"Calculate the total size of the storage in human readable format :return: the total size of the storage in a human readable string, rounded to the nearest applicable division. eg. B for Bytes, KiB for Kilobytes, MiB for Megabytes etc. \"\"\" size = await self . get_storage_size () return sizeof_fmt ( size ) New Storage Backends can be implemented by extending the following class:","title":"get_storage_size_human()"},{"location":"api/#machine.storage.backends.base.MachineBaseStorage","text":"Bases: ABC Base class for storage backends Extending classes should implement the five methods in this base class. Slack Machine takes care of a lot of details regarding the persistent storage of data. So storage backends do not have to deal with the following, because Slack Machine takes care of these: Serialization/Deserialization of data Namespacing of keys (so data stored by different plugins doesn't clash) Source code in machine/storage/backends/base.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 class MachineBaseStorage ( ABC ): \"\"\"Base class for storage backends Extending classes should implement the five methods in this base class. Slack Machine takes care of a lot of details regarding the persistent storage of data. So storage backends **do not** have to deal with the following, because Slack Machine takes care of these: - Serialization/Deserialization of data - Namespacing of keys (so data stored by different plugins doesn't clash) \"\"\" settings : Mapping [ str , Any ] def __init__ ( self , settings : Mapping [ str , Any ]): self . settings = settings async def init ( self ) -> None : \"\"\"Initialize the storage backend\"\"\" pass @abstractmethod async def get ( self , key : str ) -> bytes | None : \"\"\"Retrieve data by key :param key: key for which to retrieve data :return: the raw data for the provided key, as (byte)string. Should return ``None`` when the key is unknown or the data has expired. \"\"\" ... @abstractmethod async def set ( self , key : str , value : bytes , expires : int | None = None ) -> None : \"\"\"Store data by key :param key: the key under which to store the data :param value: data as (byte)string :param expires: optional expiration time in seconds, after which the data should not be returned any more. \"\"\" ... @abstractmethod async def delete ( self , key : str ) -> None : \"\"\"Delete data by key :param key: key for which to delete the data \"\"\" ... @abstractmethod async def has ( self , key : str ) -> bool : \"\"\"Check if the key exists :param key: key to check :return: ``True/False`` wether the key exists \"\"\" ... @abstractmethod async def size ( self ) -> int : \"\"\"Calculate the total size of the storage :return: total size of storage in bytes (integer) \"\"\" ... @abstractmethod async def close ( self ) -> None : \"\"\"Close the storage backend\"\"\" ...","title":"MachineBaseStorage"},{"location":"api/#machine.storage.backends.base.MachineBaseStorage.init","text":"Initialize the storage backend Source code in machine/storage/backends/base.py 22 23 24 async def init ( self ) -> None : \"\"\"Initialize the storage backend\"\"\" pass","title":"init()"},{"location":"api/#machine.storage.backends.base.MachineBaseStorage.get","text":"Retrieve data by key Parameters: Name Type Description Default key str key for which to retrieve data required Returns: Type Description bytes | None the raw data for the provided key, as (byte)string. Should return None when the key is unknown or the data has expired. Source code in machine/storage/backends/base.py 26 27 28 29 30 31 32 33 34 @abstractmethod async def get ( self , key : str ) -> bytes | None : \"\"\"Retrieve data by key :param key: key for which to retrieve data :return: the raw data for the provided key, as (byte)string. Should return ``None`` when the key is unknown or the data has expired. \"\"\" ...","title":"get()"},{"location":"api/#machine.storage.backends.base.MachineBaseStorage.set","text":"Store data by key Parameters: Name Type Description Default key str the key under which to store the data required value bytes data as (byte)string required expires int | None optional expiration time in seconds, after which the data should not be returned any more. None Source code in machine/storage/backends/base.py 36 37 38 39 40 41 42 43 44 45 @abstractmethod async def set ( self , key : str , value : bytes , expires : int | None = None ) -> None : \"\"\"Store data by key :param key: the key under which to store the data :param value: data as (byte)string :param expires: optional expiration time in seconds, after which the data should not be returned any more. \"\"\" ...","title":"set()"},{"location":"api/#machine.storage.backends.base.MachineBaseStorage.delete","text":"Delete data by key Parameters: Name Type Description Default key str key for which to delete the data required Source code in machine/storage/backends/base.py 47 48 49 50 51 52 53 @abstractmethod async def delete ( self , key : str ) -> None : \"\"\"Delete data by key :param key: key for which to delete the data \"\"\" ...","title":"delete()"},{"location":"api/#machine.storage.backends.base.MachineBaseStorage.has","text":"Check if the key exists Parameters: Name Type Description Default key str key to check required Returns: Type Description bool True/False wether the key exists Source code in machine/storage/backends/base.py 55 56 57 58 59 60 61 62 @abstractmethod async def has ( self , key : str ) -> bool : \"\"\"Check if the key exists :param key: key to check :return: ``True/False`` wether the key exists \"\"\" ...","title":"has()"},{"location":"api/#machine.storage.backends.base.MachineBaseStorage.size","text":"Calculate the total size of the storage Returns: Type Description int total size of storage in bytes (integer) Source code in machine/storage/backends/base.py 64 65 66 67 68 69 70 @abstractmethod async def size ( self ) -> int : \"\"\"Calculate the total size of the storage :return: total size of storage in bytes (integer) \"\"\" ...","title":"size()"},{"location":"api/#machine.storage.backends.base.MachineBaseStorage.close","text":"Close the storage backend Source code in machine/storage/backends/base.py 72 73 74 75 @abstractmethod async def close ( self ) -> None : \"\"\"Close the storage backend\"\"\" ...","title":"close()"},{"location":"changelog/","text":"Changelog All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , with a smattering of Common Changelog thrown in, most notably references , authors and prefixes . This project adheres to Semantic Versioning . Unreleased 0.32.0 - 2022-11-27 Added Add Python 3.11 support ( #676 ) Expose web client of Slack SDK ( #677 ) Changed Bump dill from 0.3.5.1 to 0.3.6 Bump slack-sdk from 3.19.1 to 3.19.4 Bump tzdata from 2022.5 to 2022.6 Bump apscheduler from 3.9.1 to 3.9.1.post1 Bump httpx from 0.23.0 to 0.23.1 Bump redis from 4.3.4 to 4.3.5 Bump structlog from 22.1.0 to 22.3.0 Fixed Fix documentation typos ( #665 by @bennylu2 ) 0.31.0 - 2022-10-21 Changed Moved Slack Machine community chat to Slack Type-hint coverage is now 100% so mypy is happy ( #633 ) Update pyproject.toml to conform to Poetry 1.2 dependency specification ( #657 ) Replace dacite with pydantic to create models for Slack API interactions ( #659 ) Bump aiohttp from 3.8.1 to 3.8.3 Bump slack-sdk from 3.18.3 to 3.19.1 Bump tzdata from 2022.4 to 2022.5 Bump aioboto3 from 10.0.0 to 10.1.0 Add changelog to keep track of updates Move to structlog for logging, fixes #599 ( #663 ) Removed Remove unused settings: DISABLE_HTTP , HTTP_SERVER_HOST , HTTP_SERVER_PORT , HTTP_SERVER_BACKEND , HTTPS_PROXY , KEEP_ALIVE 0.30.0 - 2022-08-30 Changed Bump slack-sdk from 3.18.1 to 3.18.3 ( #619 ) Removed Breaking: Remove sync version, it's all async now baby! :dancing_men: 0.28.2 - 2022-08-30 Changed Make handling changed message configurable in async mode ( #613 ) Add tests for slack client ( #614 ) 0.28.1 - 2022-08-28 Added Add support for pinning/unpinning of messages ( #611 ) Changed Add support for listening to message change events ( #594 with help from @cchadowitz-pf ) 0.28.0 - 2022-08-28 Added Add support to async version for scheduling messages and running plugin functions on a schedule ( #610 ) 0.27.2 - 2022-08-14 Fixed aioboto3 types are only relevant for type checking, so move imports inside type checking guard 0.27.1 - 2022-08-14 Changed Add documentation for DynamoDB storage backend ( #603 ) Fixed Add aioboto3 as optional dependency so extras can be satisfied ( #604 ) 0.27.0 - 2022-08-14 Added Add DynamoDB storage backend ( #602 by @jkmathes ) Add black , isort and other linters/formatters to create uniform code style ( #597 ) Changed Update documentation for builtin plugins, fixes #396 ( #598 ) Replace requests with httpx for async http calls in meme plugin and share memes as blocks ( #600 ) Replace requests with httpx for async http calls in Google image search plugin ( #601 ) 0.26.1 - 2022-08-13 Fixed Various documentation fixes Fix project metadata 0.26.0 - 2022-08-13 Added Slack Machine now supports asyncio using the Slack Events API and Socket Mode ! :racing_car: Changed Bump redis from 4.2.0 to 4.3.4 Bump slack-sdk from 3.15.2 to 3.18.1 0.25.0 - 2022-03-27 Changed Bump redis from 4.0.2 to 4.2.0 Bump slack-sdk from 3.12.0 to 3.15.2 Bump requests from 2.26.0 to 2.27.1 Bump apscheduler from 3.8.1 to 3.9.1 Fixed Fix expected payload of events when updating channel cache, fixes #526 ( #565 ) 0.24.0 - 2021-12-01 Added Add Python 3.10 support Changed Bump redis from 3.5.3 to 4.0.2 Bump apscheduler from 3.8.0 to 3.8.1 Move documentation from Sphinx to MkDocs and Material for MkDocs for beautiful docs ( #514 ) Switch from slackclient to slack_sdk library, fixes #443 Removed Breaking: Remove Python 3.6 support 0.23.2 - 2021-10-17 Fixed Bring back script to run Slack Machine 0.23.1 - 2021-10-17 Changed Document all contributors Fixed Install the right extra packages for Redis Removed Breaking: HBase storage backend has been removed 0.23.0 - 2021-10-16 Changed Switch to Poetry for project and dependency management Bump apscheduler from 3.7.0 to 3.8.0 Fixed Various CI fixes 0.22.0 - 2021-09-12 Changed Bump dill from 0.3.3 to 0.3.4 Bump requests from 2.25.1 to 2.26.0 Bump cython from 0.29.23 to 0.29.24 Use Github Actions for CI and drop Travis ( #492 ) Switch master branch to main to get with the times Fixed Only cover named channels when attempting to find a channel by name ( #483 by @arusahni ) 0.21.1 - 2021-08-01 Changed Add channel members to Channel model and keep members up-to-date through Slack events ( #485 by @arusahni ) 0.21.0 - 2021-04-25 Added Add Gitter chat room to facilitate discussions about Slack Machine Add Role-based access controls feature for plugins ( #321 by @davidolrik ) Add Python 3.9 support Changed Move to Dependabot from PyUp to manage automatic dependency updates Bump slackclient from 2.7.3 to 2.9.3 Bump requests from 2.24.0 to 2.25.1 Bump dill from 0.3.2 to 0.3.3 Bump dacite from 1.5.1 to 1.6.0 Bump cython from 0.29.21 to 0.29.23 Bump apscheduler from 3.6.3 to 3.7.0 Fixed Make channel topic creator an optional field in the Channel model ( #439 by @eguven ) Always respond to plugin functions decorated with @listen_to , also when bot is addressed in direct message ( #436 by @eddyg ) Use conversations.open endpoint on Slack WebAPI instead of im.open endpoint to open direct message conversations, because the latter is deprecated ( #401 by @cchadowitz-pf ) 0.20.1 - 2020-07-23 Fixed Use conversations.info endpoint on Slack WebAPI instead of channels.info endpoint, which is deprecated and mark optional fields as such in User and Channel objects ( #386 by @repudi8or ) 0.20.0 - 2020-07-22 Added Support Python 3.8 Changed Bump dacite from 1.0.2 to 1.5.1 Bump redis from 3.3.11 to 3.5.3 Bump cython from 0.29.14 to 0.29.21 Bump dill from 0.3.1.1 to 0.3.2 Bump requests from 2.22.0 to 2.24.0 Bump slackclient from 2.5.0 to 2.7.3 Add is_thread property to Message class ( #286 by @davidolrik ) Use conversations.list endpoint on Slack WebAPI instead of channels.list endpoint, which is deprecated and include private channels in channel cache ( #329 by @repudi8or ) Include direct messages in channel cache Add pre-commit hooks to verify basic things before commiting Fixed deleted property is optional on user responses from Slack WebAPI 0.19.2 - 2020-01-05 Changed Breaking: : thread_ts property on the Message class has been renamed to ts Fixed EchoPlugin will not respond to itself anymore Fixed PyPI classifiers 0.19.1 - 2020-01-05 Fixed Fix help plugin Fix various typos in the documentation 0.19.0 - 2020-01-05 Changed Major version upgrade of slackclient from 1.3.1 to 2.5.0 Refactor code to capture Slack API responses in dataclasses for easier development Split internal Slack client into low-level client and high-level facade Start adding type hints Breaking: self.users and self.channels on the base plugin class now return different objects than before. See API documentation for more details. These properties should behave more consistently however, even in workspaces with many users. Removed Breaking: Remove catch_all() method from base plugin class because it's not supported by the slackclient library anymore Breaking: The *_webapi methods to send messages do not exist anymore, use the regular counterparts instead. All messages are now sent using the Slack WebAPI. The RTM API is still used for listening to messages and events 0.18.2 - 2019-11-17 Fixed Fix bottle import 0.18.1 - 2019-11-17 Changed Bump apscheduler from 3.5.3 to 3.6.3 Bump redis from 3.2.0 to 3.3.11 Bump happybase from 1.1.0 to 1.2.0 Bump cython from 0.29.6 to 0.29.14 Bump dill from 0.2.9 to 0.3.1.1 Bump bottle from 0.12.16 to 0.12.17 Include bottle as a vendored dependency to not be dependent on the long release cycles of bottle Fix deprecation warnings to prepare for Python 3.8 Allow matching multiline messages in @listen_to and @respond_to decorators ( #178 by @seerickcode ) Removed Breaking: drop support for Python 3.4 and 3.5 0.18.0 - 2019-03-10 Changed Bump slackclient from 1.3.0 to 1.3.1 Bump dill from 0.2.8.2 to 0.2.9 Bump bottle from 0.12.13 to 0.12.16 Bump redis from 2.10.6 to 3.2.0 Bump Cython from 0.28.5 to 0.29.6 0.17.0 - 2018-11-10 Added Add support for bot aliases ( #108 by @seerickcode ) 0.16.1 - 2018-09-28 Changed Allow not only direct subclasses of MachineBasePlugin be plugins, but also deeper decendants ( #95 by @gfreezy ) Bump slackclient from 1.2.1 to 1.3.0 ( #88 ) 0.16.0 - 2018-09-06 Added Add HBase storage backend 0.15.0 - 2018-09-03 Added Add optional keep-alive ping in background thread to keep the connection to Slack alive ( #79 by @preludedrew ) This helps when Slack Machine is running in environments that occasionally \"go to sleep\", such as Heroku Changed Bump apscheduler from 3.5.1 to 3.5.3 Fix Python 3.7 builds by using Xenial distro 0.14.0 - 2018-07-31 Added Add Python 3.7 support Changed Add support for configuring HTTP proxy for Slack client ( #69 by @gfreezy ) 0.13.2 - 2018-07-04 Changed Make HTTP server host & port configurable ( #64 by @pirogoeth ) Bump dill from 0.2.7.1 to 0.2.8.2 Bump slackclient from 1.1.3 to 1.2.1 0.13.1 - 2018-03-06 Changed Mention webserver functionality in README 0.13.0 - 2018-03-06 [YANKED] :warning: NOTE: release was yanked due to lack of documentation Added Add webserver functionality so plugins can have functions triggered by HTTP requests Changed Bump slackclient from 1.1.2 to 1.1.3 0.12.2 - 2018-02-26 Changed Bump slackclient from 1.1.0 to 1.1.2 Memes plugin: support custom meme templates Fixed Plugin help now properly distinguishes between robot or human help 0.12.1 - 2018-01-26 Fixed Fix tests for new plugins 0.12.0 - 2018-01-26 Added Add Google Image search plugin Add memes plugin based on Memegen 0.11.0 - 2018-01-22 Added Add help feature so users can see what a bot can do based on documentation provided by plugin authors 0.10.0 - 2018-01-21 Added Add optional plugin initialization Allow plugins to mark settings as required Changed Bump apscheduler from 3.4.0 to 3.5.1 0.9.0 - 2017-12-03 Changed Bump apscheduler from 3.3.1 to 3.4.0 Bump slackclient from 1.0.9 to 1.1.0 WebAPI methods will return deserialized API responses ( #14 by @pirogoeth ) Removed Breaking: drop support for Python 3.3 0.8.0 - 2017-10-15 Added Add support for event listeners and emitting events for inter-plugin communication 0.7.0 - 2017-10-13 Added Add scheduling functionality to send messages and run plugin functions on a schedule Changed Refactor client classes to be singletons so they don't need to be persisted by APScheduler Add PyUp to automatically update dependencies 0.6.0 - 2017-09-14 Added Add pluggable plugin storage so plugins can store data Add 2 storage backends: in-memory and Redis Changed Drastically improve tests and increase coverage 0.5.0 - 2017-09-09 Changed Finish documentation 0.4.0 - 2017-09-06 Added Document how to create plugins + plugin API Changed Decorators can now be used multiple times on the same function 0.3.0 - 2017-09-03 Added Basic documentation 0.2.0 - 2017-09-01 Added Add tests and CI 0.1.0 - 2017-08-29 First release. Rejoice! :wave: Added A simple, yet powerful and extendable Slack bot framework","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , with a smattering of Common Changelog thrown in, most notably references , authors and prefixes . This project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#unreleased","text":"","title":"Unreleased"},{"location":"changelog/#0320-2022-11-27","text":"","title":"0.32.0 - 2022-11-27"},{"location":"changelog/#added","text":"Add Python 3.11 support ( #676 ) Expose web client of Slack SDK ( #677 )","title":"Added"},{"location":"changelog/#changed","text":"Bump dill from 0.3.5.1 to 0.3.6 Bump slack-sdk from 3.19.1 to 3.19.4 Bump tzdata from 2022.5 to 2022.6 Bump apscheduler from 3.9.1 to 3.9.1.post1 Bump httpx from 0.23.0 to 0.23.1 Bump redis from 4.3.4 to 4.3.5 Bump structlog from 22.1.0 to 22.3.0","title":"Changed"},{"location":"changelog/#fixed","text":"Fix documentation typos ( #665 by @bennylu2 )","title":"Fixed"},{"location":"changelog/#0310-2022-10-21","text":"","title":"0.31.0 - 2022-10-21"},{"location":"changelog/#changed_1","text":"Moved Slack Machine community chat to Slack Type-hint coverage is now 100% so mypy is happy ( #633 ) Update pyproject.toml to conform to Poetry 1.2 dependency specification ( #657 ) Replace dacite with pydantic to create models for Slack API interactions ( #659 ) Bump aiohttp from 3.8.1 to 3.8.3 Bump slack-sdk from 3.18.3 to 3.19.1 Bump tzdata from 2022.4 to 2022.5 Bump aioboto3 from 10.0.0 to 10.1.0 Add changelog to keep track of updates Move to structlog for logging, fixes #599 ( #663 )","title":"Changed"},{"location":"changelog/#removed","text":"Remove unused settings: DISABLE_HTTP , HTTP_SERVER_HOST , HTTP_SERVER_PORT , HTTP_SERVER_BACKEND , HTTPS_PROXY , KEEP_ALIVE","title":"Removed"},{"location":"changelog/#0300-2022-08-30","text":"","title":"0.30.0 - 2022-08-30"},{"location":"changelog/#changed_2","text":"Bump slack-sdk from 3.18.1 to 3.18.3 ( #619 )","title":"Changed"},{"location":"changelog/#removed_1","text":"Breaking: Remove sync version, it's all async now baby! :dancing_men:","title":"Removed"},{"location":"changelog/#0282-2022-08-30","text":"","title":"0.28.2 - 2022-08-30"},{"location":"changelog/#changed_3","text":"Make handling changed message configurable in async mode ( #613 ) Add tests for slack client ( #614 )","title":"Changed"},{"location":"changelog/#0281-2022-08-28","text":"","title":"0.28.1 - 2022-08-28"},{"location":"changelog/#added_1","text":"Add support for pinning/unpinning of messages ( #611 )","title":"Added"},{"location":"changelog/#changed_4","text":"Add support for listening to message change events ( #594 with help from @cchadowitz-pf )","title":"Changed"},{"location":"changelog/#0280-2022-08-28","text":"","title":"0.28.0 - 2022-08-28"},{"location":"changelog/#added_2","text":"Add support to async version for scheduling messages and running plugin functions on a schedule ( #610 )","title":"Added"},{"location":"changelog/#0272-2022-08-14","text":"","title":"0.27.2 - 2022-08-14"},{"location":"changelog/#fixed_1","text":"aioboto3 types are only relevant for type checking, so move imports inside type checking guard","title":"Fixed"},{"location":"changelog/#0271-2022-08-14","text":"","title":"0.27.1 - 2022-08-14"},{"location":"changelog/#changed_5","text":"Add documentation for DynamoDB storage backend ( #603 )","title":"Changed"},{"location":"changelog/#fixed_2","text":"Add aioboto3 as optional dependency so extras can be satisfied ( #604 )","title":"Fixed"},{"location":"changelog/#0270-2022-08-14","text":"","title":"0.27.0 - 2022-08-14"},{"location":"changelog/#added_3","text":"Add DynamoDB storage backend ( #602 by @jkmathes ) Add black , isort and other linters/formatters to create uniform code style ( #597 )","title":"Added"},{"location":"changelog/#changed_6","text":"Update documentation for builtin plugins, fixes #396 ( #598 ) Replace requests with httpx for async http calls in meme plugin and share memes as blocks ( #600 ) Replace requests with httpx for async http calls in Google image search plugin ( #601 )","title":"Changed"},{"location":"changelog/#0261-2022-08-13","text":"","title":"0.26.1 - 2022-08-13"},{"location":"changelog/#fixed_3","text":"Various documentation fixes Fix project metadata","title":"Fixed"},{"location":"changelog/#0260-2022-08-13","text":"","title":"0.26.0 - 2022-08-13"},{"location":"changelog/#added_4","text":"Slack Machine now supports asyncio using the Slack Events API and Socket Mode ! :racing_car:","title":"Added"},{"location":"changelog/#changed_7","text":"Bump redis from 4.2.0 to 4.3.4 Bump slack-sdk from 3.15.2 to 3.18.1","title":"Changed"},{"location":"changelog/#0250-2022-03-27","text":"","title":"0.25.0 - 2022-03-27"},{"location":"changelog/#changed_8","text":"Bump redis from 4.0.2 to 4.2.0 Bump slack-sdk from 3.12.0 to 3.15.2 Bump requests from 2.26.0 to 2.27.1 Bump apscheduler from 3.8.1 to 3.9.1","title":"Changed"},{"location":"changelog/#fixed_4","text":"Fix expected payload of events when updating channel cache, fixes #526 ( #565 )","title":"Fixed"},{"location":"changelog/#0240-2021-12-01","text":"","title":"0.24.0 - 2021-12-01"},{"location":"changelog/#added_5","text":"Add Python 3.10 support","title":"Added"},{"location":"changelog/#changed_9","text":"Bump redis from 3.5.3 to 4.0.2 Bump apscheduler from 3.8.0 to 3.8.1 Move documentation from Sphinx to MkDocs and Material for MkDocs for beautiful docs ( #514 ) Switch from slackclient to slack_sdk library, fixes #443","title":"Changed"},{"location":"changelog/#removed_2","text":"Breaking: Remove Python 3.6 support","title":"Removed"},{"location":"changelog/#0232-2021-10-17","text":"","title":"0.23.2 - 2021-10-17"},{"location":"changelog/#fixed_5","text":"Bring back script to run Slack Machine","title":"Fixed"},{"location":"changelog/#0231-2021-10-17","text":"","title":"0.23.1 - 2021-10-17"},{"location":"changelog/#changed_10","text":"Document all contributors","title":"Changed"},{"location":"changelog/#fixed_6","text":"Install the right extra packages for Redis","title":"Fixed"},{"location":"changelog/#removed_3","text":"Breaking: HBase storage backend has been removed","title":"Removed"},{"location":"changelog/#0230-2021-10-16","text":"","title":"0.23.0 - 2021-10-16"},{"location":"changelog/#changed_11","text":"Switch to Poetry for project and dependency management Bump apscheduler from 3.7.0 to 3.8.0","title":"Changed"},{"location":"changelog/#fixed_7","text":"Various CI fixes","title":"Fixed"},{"location":"changelog/#0220-2021-09-12","text":"","title":"0.22.0 - 2021-09-12"},{"location":"changelog/#changed_12","text":"Bump dill from 0.3.3 to 0.3.4 Bump requests from 2.25.1 to 2.26.0 Bump cython from 0.29.23 to 0.29.24 Use Github Actions for CI and drop Travis ( #492 ) Switch master branch to main to get with the times","title":"Changed"},{"location":"changelog/#fixed_8","text":"Only cover named channels when attempting to find a channel by name ( #483 by @arusahni )","title":"Fixed"},{"location":"changelog/#0211-2021-08-01","text":"","title":"0.21.1 - 2021-08-01"},{"location":"changelog/#changed_13","text":"Add channel members to Channel model and keep members up-to-date through Slack events ( #485 by @arusahni )","title":"Changed"},{"location":"changelog/#0210-2021-04-25","text":"","title":"0.21.0 - 2021-04-25"},{"location":"changelog/#added_6","text":"Add Gitter chat room to facilitate discussions about Slack Machine Add Role-based access controls feature for plugins ( #321 by @davidolrik ) Add Python 3.9 support","title":"Added"},{"location":"changelog/#changed_14","text":"Move to Dependabot from PyUp to manage automatic dependency updates Bump slackclient from 2.7.3 to 2.9.3 Bump requests from 2.24.0 to 2.25.1 Bump dill from 0.3.2 to 0.3.3 Bump dacite from 1.5.1 to 1.6.0 Bump cython from 0.29.21 to 0.29.23 Bump apscheduler from 3.6.3 to 3.7.0","title":"Changed"},{"location":"changelog/#fixed_9","text":"Make channel topic creator an optional field in the Channel model ( #439 by @eguven ) Always respond to plugin functions decorated with @listen_to , also when bot is addressed in direct message ( #436 by @eddyg ) Use conversations.open endpoint on Slack WebAPI instead of im.open endpoint to open direct message conversations, because the latter is deprecated ( #401 by @cchadowitz-pf )","title":"Fixed"},{"location":"changelog/#0201-2020-07-23","text":"","title":"0.20.1 - 2020-07-23"},{"location":"changelog/#fixed_10","text":"Use conversations.info endpoint on Slack WebAPI instead of channels.info endpoint, which is deprecated and mark optional fields as such in User and Channel objects ( #386 by @repudi8or )","title":"Fixed"},{"location":"changelog/#0200-2020-07-22","text":"","title":"0.20.0 - 2020-07-22"},{"location":"changelog/#added_7","text":"Support Python 3.8","title":"Added"},{"location":"changelog/#changed_15","text":"Bump dacite from 1.0.2 to 1.5.1 Bump redis from 3.3.11 to 3.5.3 Bump cython from 0.29.14 to 0.29.21 Bump dill from 0.3.1.1 to 0.3.2 Bump requests from 2.22.0 to 2.24.0 Bump slackclient from 2.5.0 to 2.7.3 Add is_thread property to Message class ( #286 by @davidolrik ) Use conversations.list endpoint on Slack WebAPI instead of channels.list endpoint, which is deprecated and include private channels in channel cache ( #329 by @repudi8or ) Include direct messages in channel cache Add pre-commit hooks to verify basic things before commiting","title":"Changed"},{"location":"changelog/#fixed_11","text":"deleted property is optional on user responses from Slack WebAPI","title":"Fixed"},{"location":"changelog/#0192-2020-01-05","text":"","title":"0.19.2 - 2020-01-05"},{"location":"changelog/#changed_16","text":"Breaking: : thread_ts property on the Message class has been renamed to ts","title":"Changed"},{"location":"changelog/#fixed_12","text":"EchoPlugin will not respond to itself anymore Fixed PyPI classifiers","title":"Fixed"},{"location":"changelog/#0191-2020-01-05","text":"","title":"0.19.1 - 2020-01-05"},{"location":"changelog/#fixed_13","text":"Fix help plugin Fix various typos in the documentation","title":"Fixed"},{"location":"changelog/#0190-2020-01-05","text":"","title":"0.19.0 - 2020-01-05"},{"location":"changelog/#changed_17","text":"Major version upgrade of slackclient from 1.3.1 to 2.5.0 Refactor code to capture Slack API responses in dataclasses for easier development Split internal Slack client into low-level client and high-level facade Start adding type hints Breaking: self.users and self.channels on the base plugin class now return different objects than before. See API documentation for more details. These properties should behave more consistently however, even in workspaces with many users.","title":"Changed"},{"location":"changelog/#removed_4","text":"Breaking: Remove catch_all() method from base plugin class because it's not supported by the slackclient library anymore Breaking: The *_webapi methods to send messages do not exist anymore, use the regular counterparts instead. All messages are now sent using the Slack WebAPI. The RTM API is still used for listening to messages and events","title":"Removed"},{"location":"changelog/#0182-2019-11-17","text":"","title":"0.18.2 - 2019-11-17"},{"location":"changelog/#fixed_14","text":"Fix bottle import","title":"Fixed"},{"location":"changelog/#0181-2019-11-17","text":"","title":"0.18.1 - 2019-11-17"},{"location":"changelog/#changed_18","text":"Bump apscheduler from 3.5.3 to 3.6.3 Bump redis from 3.2.0 to 3.3.11 Bump happybase from 1.1.0 to 1.2.0 Bump cython from 0.29.6 to 0.29.14 Bump dill from 0.2.9 to 0.3.1.1 Bump bottle from 0.12.16 to 0.12.17 Include bottle as a vendored dependency to not be dependent on the long release cycles of bottle Fix deprecation warnings to prepare for Python 3.8 Allow matching multiline messages in @listen_to and @respond_to decorators ( #178 by @seerickcode )","title":"Changed"},{"location":"changelog/#removed_5","text":"Breaking: drop support for Python 3.4 and 3.5","title":"Removed"},{"location":"changelog/#0180-2019-03-10","text":"","title":"0.18.0 - 2019-03-10"},{"location":"changelog/#changed_19","text":"Bump slackclient from 1.3.0 to 1.3.1 Bump dill from 0.2.8.2 to 0.2.9 Bump bottle from 0.12.13 to 0.12.16 Bump redis from 2.10.6 to 3.2.0 Bump Cython from 0.28.5 to 0.29.6","title":"Changed"},{"location":"changelog/#0170-2018-11-10","text":"","title":"0.17.0 - 2018-11-10"},{"location":"changelog/#added_8","text":"Add support for bot aliases ( #108 by @seerickcode )","title":"Added"},{"location":"changelog/#0161-2018-09-28","text":"","title":"0.16.1 - 2018-09-28"},{"location":"changelog/#changed_20","text":"Allow not only direct subclasses of MachineBasePlugin be plugins, but also deeper decendants ( #95 by @gfreezy ) Bump slackclient from 1.2.1 to 1.3.0 ( #88 )","title":"Changed"},{"location":"changelog/#0160-2018-09-06","text":"","title":"0.16.0 - 2018-09-06"},{"location":"changelog/#added_9","text":"Add HBase storage backend","title":"Added"},{"location":"changelog/#0150-2018-09-03","text":"","title":"0.15.0 - 2018-09-03"},{"location":"changelog/#added_10","text":"Add optional keep-alive ping in background thread to keep the connection to Slack alive ( #79 by @preludedrew ) This helps when Slack Machine is running in environments that occasionally \"go to sleep\", such as Heroku","title":"Added"},{"location":"changelog/#changed_21","text":"Bump apscheduler from 3.5.1 to 3.5.3 Fix Python 3.7 builds by using Xenial distro","title":"Changed"},{"location":"changelog/#0140-2018-07-31","text":"","title":"0.14.0 - 2018-07-31"},{"location":"changelog/#added_11","text":"Add Python 3.7 support","title":"Added"},{"location":"changelog/#changed_22","text":"Add support for configuring HTTP proxy for Slack client ( #69 by @gfreezy )","title":"Changed"},{"location":"changelog/#0132-2018-07-04","text":"","title":"0.13.2 - 2018-07-04"},{"location":"changelog/#changed_23","text":"Make HTTP server host & port configurable ( #64 by @pirogoeth ) Bump dill from 0.2.7.1 to 0.2.8.2 Bump slackclient from 1.1.3 to 1.2.1","title":"Changed"},{"location":"changelog/#0131-2018-03-06","text":"","title":"0.13.1 - 2018-03-06"},{"location":"changelog/#changed_24","text":"Mention webserver functionality in README","title":"Changed"},{"location":"changelog/#0130-2018-03-06-yanked","text":":warning: NOTE: release was yanked due to lack of documentation","title":"0.13.0 - 2018-03-06 [YANKED]"},{"location":"changelog/#added_12","text":"Add webserver functionality so plugins can have functions triggered by HTTP requests","title":"Added"},{"location":"changelog/#changed_25","text":"Bump slackclient from 1.1.2 to 1.1.3","title":"Changed"},{"location":"changelog/#0122-2018-02-26","text":"","title":"0.12.2 - 2018-02-26"},{"location":"changelog/#changed_26","text":"Bump slackclient from 1.1.0 to 1.1.2 Memes plugin: support custom meme templates","title":"Changed"},{"location":"changelog/#fixed_15","text":"Plugin help now properly distinguishes between robot or human help","title":"Fixed"},{"location":"changelog/#0121-2018-01-26","text":"","title":"0.12.1 - 2018-01-26"},{"location":"changelog/#fixed_16","text":"Fix tests for new plugins","title":"Fixed"},{"location":"changelog/#0120-2018-01-26","text":"","title":"0.12.0 - 2018-01-26"},{"location":"changelog/#added_13","text":"Add Google Image search plugin Add memes plugin based on Memegen","title":"Added"},{"location":"changelog/#0110-2018-01-22","text":"","title":"0.11.0 - 2018-01-22"},{"location":"changelog/#added_14","text":"Add help feature so users can see what a bot can do based on documentation provided by plugin authors","title":"Added"},{"location":"changelog/#0100-2018-01-21","text":"","title":"0.10.0 - 2018-01-21"},{"location":"changelog/#added_15","text":"Add optional plugin initialization Allow plugins to mark settings as required","title":"Added"},{"location":"changelog/#changed_27","text":"Bump apscheduler from 3.4.0 to 3.5.1","title":"Changed"},{"location":"changelog/#090-2017-12-03","text":"","title":"0.9.0 - 2017-12-03"},{"location":"changelog/#changed_28","text":"Bump apscheduler from 3.3.1 to 3.4.0 Bump slackclient from 1.0.9 to 1.1.0 WebAPI methods will return deserialized API responses ( #14 by @pirogoeth )","title":"Changed"},{"location":"changelog/#removed_6","text":"Breaking: drop support for Python 3.3","title":"Removed"},{"location":"changelog/#080-2017-10-15","text":"","title":"0.8.0 - 2017-10-15"},{"location":"changelog/#added_16","text":"Add support for event listeners and emitting events for inter-plugin communication","title":"Added"},{"location":"changelog/#070-2017-10-13","text":"","title":"0.7.0 - 2017-10-13"},{"location":"changelog/#added_17","text":"Add scheduling functionality to send messages and run plugin functions on a schedule","title":"Added"},{"location":"changelog/#changed_29","text":"Refactor client classes to be singletons so they don't need to be persisted by APScheduler Add PyUp to automatically update dependencies","title":"Changed"},{"location":"changelog/#060-2017-09-14","text":"","title":"0.6.0 - 2017-09-14"},{"location":"changelog/#added_18","text":"Add pluggable plugin storage so plugins can store data Add 2 storage backends: in-memory and Redis","title":"Added"},{"location":"changelog/#changed_30","text":"Drastically improve tests and increase coverage","title":"Changed"},{"location":"changelog/#050-2017-09-09","text":"","title":"0.5.0 - 2017-09-09"},{"location":"changelog/#changed_31","text":"Finish documentation","title":"Changed"},{"location":"changelog/#040-2017-09-06","text":"","title":"0.4.0 - 2017-09-06"},{"location":"changelog/#added_19","text":"Document how to create plugins + plugin API","title":"Added"},{"location":"changelog/#changed_32","text":"Decorators can now be used multiple times on the same function","title":"Changed"},{"location":"changelog/#030-2017-09-03","text":"","title":"0.3.0 - 2017-09-03"},{"location":"changelog/#added_20","text":"Basic documentation","title":"Added"},{"location":"changelog/#020-2017-09-01","text":"","title":"0.2.0 - 2017-09-01"},{"location":"changelog/#added_21","text":"Add tests and CI","title":"Added"},{"location":"changelog/#010-2017-08-29","text":"First release. Rejoice! :wave:","title":"0.1.0 - 2017-08-29"},{"location":"changelog/#added_22","text":"A simple, yet powerful and extendable Slack bot framework","title":"Added"},{"location":"migrating/","text":"Migrating plugins to async As of v0.30.0 Slack Machine dropped support for the old backend based on the RTM API. As such, Slack Machine is now fully based on AsyncIO . This means plugins written before the rewrite to asyncio aren't supported anymore. This is a migration guide to get your old plugins working with the new version of Slack Machine. Await all Slack Machine plugin functions Any function from MachineBasePlugin and Message needs to be awaited now. This is as easy as prefixing your the function calls with the await keyword: await self . say ( \"#general\" , \"Hello there baby!\" ) All of your plugin functions need to be async Because you're awaiting methods from the Slack Machine plugin classes now, the functions you define in your own plugins, need to be async . This is as easy as prefixing your function definitions with the async keyword: class MyPlugin ( MachineBasePlugin ): @listen_to ( r \"^hello\" ) async def hello ( self , msg ): msg . say ( \"world\" )","title":"Migrating plugins to async"},{"location":"migrating/#migrating-plugins-to-async","text":"As of v0.30.0 Slack Machine dropped support for the old backend based on the RTM API. As such, Slack Machine is now fully based on AsyncIO . This means plugins written before the rewrite to asyncio aren't supported anymore. This is a migration guide to get your old plugins working with the new version of Slack Machine.","title":"Migrating plugins to async"},{"location":"migrating/#await-all-slack-machine-plugin-functions","text":"Any function from MachineBasePlugin and Message needs to be awaited now. This is as easy as prefixing your the function calls with the await keyword: await self . say ( \"#general\" , \"Hello there baby!\" )","title":"Await all Slack Machine plugin functions"},{"location":"migrating/#all-of-your-plugin-functions-need-to-be-async","text":"Because you're awaiting methods from the Slack Machine plugin classes now, the functions you define in your own plugins, need to be async . This is as easy as prefixing your function definitions with the async keyword: class MyPlugin ( MachineBasePlugin ): @listen_to ( r \"^hello\" ) async def hello ( self , msg ): msg . say ( \"world\" )","title":"All of your plugin functions need to be async"},{"location":"plugins/basics/","text":"Plugin Basics Writing plugins for Slack Machine is easy. To show you how easy, we'll build and run a simple plugin from start to finish. To be able to follow this guide, you have to have installed and configured Slack Machine first! The Base class for plugins Plugins in Slack Machine are classes that subclass MachineBasePlugin . Inheriting from this class tells Slack Machine that we're dealing with a plugin. But that's not even the most exciting part! With this base class, your plugin immediately has a lot of functionality at its disposal that makes it super easy to do anything from talking to channels, responding to messages, sending DMs, and much more! The decorators Being able to talk in Slack is only half the story for plugins. The functions in your plugin have to be triggered somehow. Slack Machine provides decorators for that. You can decorate the functions in your plugin class to tell them what they should react to. As an example, let's create a cool plugin! Step 1: Creating the plugin We're going to create a plugin that listens for The Answer , and responds in kind. In the root of your bot (where your local_settings.py lives), create a plugins folder. In it, create an __init__.py (so your plugins folder becomes a package) and a file named hitchhikers.py . Your folder structure should look like this: \u251c\u2500\u2500 local_settings.py \u2514\u2500\u2500 plugins \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 hitchhikers.py Step 2: Adding the code First, we should import the MachineBasePlugin in our code, and the decorator to listen for specific messages. Then we can create our plugin class that includes a function that listens for The Answer, and responds to it: from machine.plugins.base import MachineBasePlugin from machine.plugins.decorators import listen_to import re class UltimateQuestionPlugin ( MachineBasePlugin ): @listen_to ( regex = r \"^42$\" ) async def question ( self , msg ): await msg . say ( \"You're telling me the Answer to the Ultimate Question of Life, the Universe and Everything, \" , \"but I don't know the question :cry:\" ) Tip As Slack-Machine is fully built on top of Python's excellent AsyncIO library , all of the functionality that Slack Machine offers (e.g. sending messages, adding reactions etc.) comes in the form of async functions, a.k.a. coroutines . This means that the plugin functions you define, have to be coroutines as well! This will take a while to get used to, but the reward is that Slack Machine is able to run your plugin functions concurrently. Step 3: Enabling our plugin Now we can enable our plugin in our configuration file. Your local_settings.py should look like this: SLACK_APP_TOKEN = \"xapp-my-app-token\" SLACK_BOT_TOKEN = \"xoxb-my-bot-token\" PLUGINS = [ \"machine.plugins.builtin.general.HelloPlugin\" , \"machine.plugins.builtin.general.PingPongPlugin\" , \"plugins.hitchhikers.UltimateQuestionPlugin\" ] Step 4: Run that bot! To run your bot with the new plugin: $ slack-machine That's all there is to it!","title":"Plugin Basics"},{"location":"plugins/basics/#plugin-basics","text":"Writing plugins for Slack Machine is easy. To show you how easy, we'll build and run a simple plugin from start to finish. To be able to follow this guide, you have to have installed and configured Slack Machine first!","title":"Plugin Basics"},{"location":"plugins/basics/#the-base-class-for-plugins","text":"Plugins in Slack Machine are classes that subclass MachineBasePlugin . Inheriting from this class tells Slack Machine that we're dealing with a plugin. But that's not even the most exciting part! With this base class, your plugin immediately has a lot of functionality at its disposal that makes it super easy to do anything from talking to channels, responding to messages, sending DMs, and much more!","title":"The Base class for plugins"},{"location":"plugins/basics/#the-decorators","text":"Being able to talk in Slack is only half the story for plugins. The functions in your plugin have to be triggered somehow. Slack Machine provides decorators for that. You can decorate the functions in your plugin class to tell them what they should react to. As an example, let's create a cool plugin!","title":"The decorators"},{"location":"plugins/basics/#step-1-creating-the-plugin","text":"We're going to create a plugin that listens for The Answer , and responds in kind. In the root of your bot (where your local_settings.py lives), create a plugins folder. In it, create an __init__.py (so your plugins folder becomes a package) and a file named hitchhikers.py . Your folder structure should look like this: \u251c\u2500\u2500 local_settings.py \u2514\u2500\u2500 plugins \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 hitchhikers.py","title":"Step 1: Creating the plugin"},{"location":"plugins/basics/#step-2-adding-the-code","text":"First, we should import the MachineBasePlugin in our code, and the decorator to listen for specific messages. Then we can create our plugin class that includes a function that listens for The Answer, and responds to it: from machine.plugins.base import MachineBasePlugin from machine.plugins.decorators import listen_to import re class UltimateQuestionPlugin ( MachineBasePlugin ): @listen_to ( regex = r \"^42$\" ) async def question ( self , msg ): await msg . say ( \"You're telling me the Answer to the Ultimate Question of Life, the Universe and Everything, \" , \"but I don't know the question :cry:\" ) Tip As Slack-Machine is fully built on top of Python's excellent AsyncIO library , all of the functionality that Slack Machine offers (e.g. sending messages, adding reactions etc.) comes in the form of async functions, a.k.a. coroutines . This means that the plugin functions you define, have to be coroutines as well! This will take a while to get used to, but the reward is that Slack Machine is able to run your plugin functions concurrently.","title":"Step 2: Adding the code"},{"location":"plugins/basics/#step-3-enabling-our-plugin","text":"Now we can enable our plugin in our configuration file. Your local_settings.py should look like this: SLACK_APP_TOKEN = \"xapp-my-app-token\" SLACK_BOT_TOKEN = \"xoxb-my-bot-token\" PLUGINS = [ \"machine.plugins.builtin.general.HelloPlugin\" , \"machine.plugins.builtin.general.PingPongPlugin\" , \"plugins.hitchhikers.UltimateQuestionPlugin\" ]","title":"Step 3: Enabling our plugin"},{"location":"plugins/basics/#step-4-run-that-bot","text":"To run your bot with the new plugin: $ slack-machine That's all there is to it!","title":"Step 4: Run that bot!"},{"location":"plugins/interacting/","text":"How to interact Slack Machine provides several convenient ways to interact with channels and users in your Slack workspace. To this end, two very similar sets of functions are exposed through two classes: MachineBasePlugin The MachineBasePlugin class every plugin extends, provides methods to send messages to channels (public, private and DM), using the WebAPI, with support for rich messages/blocks/attachment. It also supports adding reactions to messages, pinning and unpinning messages, replying in-thread, sending ephemeral messages to a channel (only visible to 1 user), and much more. Message An instance of the Message class is automatically supplied to your plugin functions when using the @respond_to or @respond_to decorators. It has a similar set of methods as the MachineBasePlugin class, but without the need to manually specify the channel you want to talk to. It lets you send messages and reply to messages in the same channel the original message was received in. It is recommended to use the passed-in Message object to interact with channels and users, whenever you use the @respond_to or @respond_to decorators, as this takes away the pain of having to manually target the right channels. For a detailed description of all the methods available to you, please read the api documentation . What follows are some examples of how you would respond in common scenarios. Responding to a message If your plugin receives a message through the @respond_to or @listen_to decorators, the simplest way to reply is using msg.reply() . It takes 2 parameters: text : the message you want to send in_thread : if Slack Machine should reply to the original message in-thread msg.reply() will start the reply with a mention of the sender of the original message. Example: @respond_to ( r \"^I love you\" ) async def spread_love ( self , msg ): await msg . reply ( \"I love you too!\" ) If this function is triggered by a message @superbot I love you , sent by @john , the response will be: @john: I love you too! msg.reply() will use the Slack WebAPI to send messages, which means you can send richly formatted messages using blocks and/or attachments . The underlying Python slack-sdk that Slack Machine uses, provides some convenience classes that can help with creating blocks or attachments. All Slack Machine methods that can be used to send messages, accept lists of Block objects and/or Attachment objects from the aforementioned convience classes. This method has 2 extra parameters that unlock 2 extra features: ephemeral : if True , the message will be visible only to the sender of the original message. in_thread : this will send the message in a thread instead of to the main channel There is 1 more method to respond to a message in the same channel: msg.say() is very similar to its reply counterpart, with the exception that it won't mention the sender of the original message. If you want to reply to the sender of the original message in a DM instead of in the original channel, you can use the msg.reply_dm() methods. This will open a DM convo between the sender of the original message and the bot (if it doesn't exist already) and send a message there. If the original message was already received in a DM channel, this is no different from using reply() . Message properties The Message object your plugin function receives, has some convenient properties about the message that triggered the function: sender : a User object with information about the sender, such as their id and name channel : a Channel object with information about the channel the message was received in text : the contents of the original message Plugin properties The MachineBasePlugin class every plugin extends, exposes some properties about your Slack workspace. These properties are not filled when your plugin is instantiated, but reflect the current status of the Slack client: users : a dict of user ids and the associated User objects for all users that Slack Machine knows about. This is usually all the active users in your Slack workspace. This data structure is filled when Slack Machine starts and is automatically updated whenever a new user joins or the properties of a user change. channels : a dict of channel ids and the associated User objects for channels that Slack Machine knows about. This contains all the public channels in your Slack workspace, plus all private channels that your Slack Machine instance was invited to. Sending messages without a msg object There are situations in which you want to send messages to users/channels, but there is no original message to respond to. For example when implementing your own event listener using the @process decorator. In this case you can call functions similar as those described before, but from your plugin itself: self.say() and self.send_dm() . These behave similar to their Message counterparts, except that they require a channel id or object, or user id or object (in case of DM) to be passed in. You can use find_channel_by_name() to find the channel you want to send a message to. Scheduling messages Sometimes you want to reply to a message, send a message to some channel, send a DM etc. but you don't want to do it now . You want to do it in the future . Slack Machine provides scheduled versions of many methods, both in the MachineBasePlugin all plugins extend from and in the Message object @respond_to and @respond_to functions receive. These methods can be recognized by their _scheduled prefix. They work almost the same as their regular counterparts, except that they receive 1 extra argument: a datetime object that tells Slack Machine when to send the message. Example: @respond_to ( r \"greet me in the future\" ) async def future ( self , msg ): await msg . say ( \"command received!\" ) in_10_sec = datetime . now () + timedelta ( seconds = 10 ) await msg . reply_dm_scheduled ( in_10_sec , \"A Delayed Hello!\" ) This function will send a greeting 10 seconds after it has received a message: @superbot greet me in the future . Caveat You cannot schedule a reaction to a message. It doesn't make sense to react to a message in the future. For more information about scheduling message, have a look at the api documentation . Protecting commands Sometimes you may want to restrict certain commands in your bot, so they can only be invoked by certain users. To use these restrictions you must appoint one user to be the root user . For security reasons there can be only one root user , and it must be configured through local_settings.py or environment variables. That way you will never lose control over your bot. To enable all the role based features, your local_settings.py would look something like this: SLACK_APP_TOKEN = \"xapp-my-app-token\" SLACK_BOT_TOKEN = \"xoxb-my-bot-token\" ROOT_USER = \"0000007\" PLUGINS = [ 'machine.plugins.builtin.admin.RBACPlugin' , ] You can get the member ID from a user by going to their Slack profile, clicking more and selecting Copy member ID . If you wish to share the powers of root you can enable the RBAC admin plugin machine.plugins.builtin.admin.RBACPlugin and grant the admin role to users you trust. The RBAC plugin provides you with three new commands that lets you lookup, grant and revoke roles to users: @superbot who has role admin @superbot grant role admin to @trusted-user @superbot revoke role admin from @trusted-user . Now you can decorate certain functions in your plugin with the @require_any_role or @require_all_roles decorators to make them only usable by users with certain roles. Here is an example of a command that requires either the admin or channel role: @respond_to ( r \"^say in\" r \"\\s+<#\\w+\\|(?P<channel_name>[^>]+)>\" r \"\\s+(?P<message>.+)\" ) @require_any_role ([ \"admin\" , \"channel\" ]) async def say_in_channel ( self , msg , channel_name , message ): logging . info ( channel_name ) await self . say ( channel_name , message ) You can define as many roles as you want, any string without spaces is acceptable. Emitting events Your plugin can emit arbitrary events that other plugins (or your own) can listen for. Events are a convenient mechanism for exchanging data between plugins and/or for a plugin to expose an api that other plugins can hook into. Emitting an event is done with self.emit() . You have to provide a name for the event you want to emit, so others can listen for an event by that name. You can optionally provide extra data as keyword arguments. Example: @respond_to ( r \"I have used the bathroom\" ) async def broadcast_bathroom_usage ( self , msg ): self . emit ( 'bathroom_used' , toilet_flushed = True ) You can read the events section to see how your plugin can listen for events. Using the Slack Web API in other ways Sometimes you want to use Slack Web API in ways that are not directly exposed by MachineBaserPlugin . In these cases you can use self.web_client . self.web_client references the AsyncWebClient object of the underlying Slack Python SDK.","title":"How to interact"},{"location":"plugins/interacting/#how-to-interact","text":"Slack Machine provides several convenient ways to interact with channels and users in your Slack workspace. To this end, two very similar sets of functions are exposed through two classes:","title":"How to interact"},{"location":"plugins/interacting/#machinebaseplugin","text":"The MachineBasePlugin class every plugin extends, provides methods to send messages to channels (public, private and DM), using the WebAPI, with support for rich messages/blocks/attachment. It also supports adding reactions to messages, pinning and unpinning messages, replying in-thread, sending ephemeral messages to a channel (only visible to 1 user), and much more.","title":"MachineBasePlugin"},{"location":"plugins/interacting/#message","text":"An instance of the Message class is automatically supplied to your plugin functions when using the @respond_to or @respond_to decorators. It has a similar set of methods as the MachineBasePlugin class, but without the need to manually specify the channel you want to talk to. It lets you send messages and reply to messages in the same channel the original message was received in. It is recommended to use the passed-in Message object to interact with channels and users, whenever you use the @respond_to or @respond_to decorators, as this takes away the pain of having to manually target the right channels. For a detailed description of all the methods available to you, please read the api documentation . What follows are some examples of how you would respond in common scenarios.","title":"Message"},{"location":"plugins/interacting/#responding-to-a-message","text":"If your plugin receives a message through the @respond_to or @listen_to decorators, the simplest way to reply is using msg.reply() . It takes 2 parameters: text : the message you want to send in_thread : if Slack Machine should reply to the original message in-thread msg.reply() will start the reply with a mention of the sender of the original message. Example: @respond_to ( r \"^I love you\" ) async def spread_love ( self , msg ): await msg . reply ( \"I love you too!\" ) If this function is triggered by a message @superbot I love you , sent by @john , the response will be: @john: I love you too! msg.reply() will use the Slack WebAPI to send messages, which means you can send richly formatted messages using blocks and/or attachments . The underlying Python slack-sdk that Slack Machine uses, provides some convenience classes that can help with creating blocks or attachments. All Slack Machine methods that can be used to send messages, accept lists of Block objects and/or Attachment objects from the aforementioned convience classes. This method has 2 extra parameters that unlock 2 extra features: ephemeral : if True , the message will be visible only to the sender of the original message. in_thread : this will send the message in a thread instead of to the main channel There is 1 more method to respond to a message in the same channel: msg.say() is very similar to its reply counterpart, with the exception that it won't mention the sender of the original message. If you want to reply to the sender of the original message in a DM instead of in the original channel, you can use the msg.reply_dm() methods. This will open a DM convo between the sender of the original message and the bot (if it doesn't exist already) and send a message there. If the original message was already received in a DM channel, this is no different from using reply() .","title":"Responding to a message"},{"location":"plugins/interacting/#message-properties","text":"The Message object your plugin function receives, has some convenient properties about the message that triggered the function: sender : a User object with information about the sender, such as their id and name channel : a Channel object with information about the channel the message was received in text : the contents of the original message","title":"Message properties"},{"location":"plugins/interacting/#plugin-properties","text":"The MachineBasePlugin class every plugin extends, exposes some properties about your Slack workspace. These properties are not filled when your plugin is instantiated, but reflect the current status of the Slack client: users : a dict of user ids and the associated User objects for all users that Slack Machine knows about. This is usually all the active users in your Slack workspace. This data structure is filled when Slack Machine starts and is automatically updated whenever a new user joins or the properties of a user change. channels : a dict of channel ids and the associated User objects for channels that Slack Machine knows about. This contains all the public channels in your Slack workspace, plus all private channels that your Slack Machine instance was invited to.","title":"Plugin properties"},{"location":"plugins/interacting/#sending-messages-without-a-msg-object","text":"There are situations in which you want to send messages to users/channels, but there is no original message to respond to. For example when implementing your own event listener using the @process decorator. In this case you can call functions similar as those described before, but from your plugin itself: self.say() and self.send_dm() . These behave similar to their Message counterparts, except that they require a channel id or object, or user id or object (in case of DM) to be passed in. You can use find_channel_by_name() to find the channel you want to send a message to.","title":"Sending messages without a msg object"},{"location":"plugins/interacting/#scheduling-messages","text":"Sometimes you want to reply to a message, send a message to some channel, send a DM etc. but you don't want to do it now . You want to do it in the future . Slack Machine provides scheduled versions of many methods, both in the MachineBasePlugin all plugins extend from and in the Message object @respond_to and @respond_to functions receive. These methods can be recognized by their _scheduled prefix. They work almost the same as their regular counterparts, except that they receive 1 extra argument: a datetime object that tells Slack Machine when to send the message. Example: @respond_to ( r \"greet me in the future\" ) async def future ( self , msg ): await msg . say ( \"command received!\" ) in_10_sec = datetime . now () + timedelta ( seconds = 10 ) await msg . reply_dm_scheduled ( in_10_sec , \"A Delayed Hello!\" ) This function will send a greeting 10 seconds after it has received a message: @superbot greet me in the future . Caveat You cannot schedule a reaction to a message. It doesn't make sense to react to a message in the future. For more information about scheduling message, have a look at the api documentation .","title":"Scheduling messages"},{"location":"plugins/interacting/#protecting-commands","text":"Sometimes you may want to restrict certain commands in your bot, so they can only be invoked by certain users. To use these restrictions you must appoint one user to be the root user . For security reasons there can be only one root user , and it must be configured through local_settings.py or environment variables. That way you will never lose control over your bot. To enable all the role based features, your local_settings.py would look something like this: SLACK_APP_TOKEN = \"xapp-my-app-token\" SLACK_BOT_TOKEN = \"xoxb-my-bot-token\" ROOT_USER = \"0000007\" PLUGINS = [ 'machine.plugins.builtin.admin.RBACPlugin' , ] You can get the member ID from a user by going to their Slack profile, clicking more and selecting Copy member ID . If you wish to share the powers of root you can enable the RBAC admin plugin machine.plugins.builtin.admin.RBACPlugin and grant the admin role to users you trust. The RBAC plugin provides you with three new commands that lets you lookup, grant and revoke roles to users: @superbot who has role admin @superbot grant role admin to @trusted-user @superbot revoke role admin from @trusted-user . Now you can decorate certain functions in your plugin with the @require_any_role or @require_all_roles decorators to make them only usable by users with certain roles. Here is an example of a command that requires either the admin or channel role: @respond_to ( r \"^say in\" r \"\\s+<#\\w+\\|(?P<channel_name>[^>]+)>\" r \"\\s+(?P<message>.+)\" ) @require_any_role ([ \"admin\" , \"channel\" ]) async def say_in_channel ( self , msg , channel_name , message ): logging . info ( channel_name ) await self . say ( channel_name , message ) You can define as many roles as you want, any string without spaces is acceptable.","title":"Protecting commands"},{"location":"plugins/interacting/#emitting-events","text":"Your plugin can emit arbitrary events that other plugins (or your own) can listen for. Events are a convenient mechanism for exchanging data between plugins and/or for a plugin to expose an api that other plugins can hook into. Emitting an event is done with self.emit() . You have to provide a name for the event you want to emit, so others can listen for an event by that name. You can optionally provide extra data as keyword arguments. Example: @respond_to ( r \"I have used the bathroom\" ) async def broadcast_bathroom_usage ( self , msg ): self . emit ( 'bathroom_used' , toilet_flushed = True ) You can read the events section to see how your plugin can listen for events.","title":"Emitting events"},{"location":"plugins/interacting/#using-the-slack-web-api-in-other-ways","text":"Sometimes you want to use Slack Web API in ways that are not directly exposed by MachineBaserPlugin . In these cases you can use self.web_client . self.web_client references the AsyncWebClient object of the underlying Slack Python SDK.","title":"Using the Slack Web API in other ways"},{"location":"plugins/listening/","text":"Listening for things Slack Machine allows you to listen for various different things and respond to that. By decorating functions in your plugin using the decorators Slack Machine provides, you can tell Slack Machine to run those functions when something specific happens. Listen for a mention The respond_to decorator tells Slack Machine to listen for messages mentioning your bot and matching a specific pattern. Slack Machine will hear messages sent in any channel or private group it is a member of. For a message to trigger a function decorated by @respond_to(...) , the message has to start with a mention of your bot or with any alias the user configured using the ALIASES setting. The exception is direct messages sent to the bot, they don't have to include a mention to trigger @respond_to . @respond_to takes 3 parameters: regex ( required ): the regular expression Slack Machine should listen for. The regex pattern should not account for the mention of your bot, as Slack Machine will remove the mention before looking for a match. Slack Machine listens for any occurrence of the pattern in the message, so if you want to specifically match the whole message, you can anchor your pattern using the ^ and $ symbols. flags (optional): can be used to pass flags for the regex matching as defined in the re module. By default, re.IGNORECASE is applied. handle_message_changed (optional): is used to configure if Slack Machine should trigger this function for messages that have been changed . By default, only new messages will trigger the decorated function. How your function will be called Your function will be called with a Message object that represents the message that triggered the function. It not only contains the message text itself, but also has many convenient methods for replying. Example: @respond_to ( r \"^I love you\" ) async def spread_love ( self , msg ): await msg . reply ( \"I love you too!\" ) The regex pattern can optionally contain named groups that will be captured and passed to your function as keyword arguments. Example: @respond_to ( r \"You deserve (?P<num_stars>\\d+) stars!\" ) async def award ( self , msg , num_stars ): stars_back = int ( num_stars ) + 1 await msg . reply ( \"Well, you deserve {} !\" . format ( stars_back )) Hear any message The @listen_to decorator works similar as the @respond_to decorator, but it will hear any message matching a pattern, without the bot being explicitly mentioned. @listen_to takes the same parameters as @respond_to . Example: @listen_to ( r \"go for it\" ) @listen_to ( r \"go 4 it\" ) async def go_for_it ( self , msg ): await msg . say ( \"https://a-z-animals.com/media/animals/images/original/gopher_2.jpg\" ) As you can see, you can also apply the same decorator multiple times to a function, each time with different arguments. Of course, you can also combine different decorators on one function. More flexibility with Slack events If you want your bot to respond to other things than messages, you can do so using the @process decorator. @process requires an event_type as parameter and will trigger the decorated function any time an event of the specified type happens. It can listen to any Slack event that is supported by the Events API. The received event will be passed to your function. The following example will listen for the reaction_added event to know if a reaction was added to a message, and will match that reaction: @process ( \"reaction_added\" ) async def match_reaction ( self , event ): emoji = event [ \"reaction\" ] channel = event [ \"item\" ][ \"channel\" ] ts = event [ \"item\" ][ \"ts\" ] await self . react ( channel , ts , emoji ) As you can see, @process gives you a lot of flexibility by allowing you to process any event Slack Machine does not provide a specific decorator for. Take action on a Schedule Slack Machine can also run functions on a schedule, using the @schedule decorator. @schedule behaves like Linux/Unix Crontab , and receives similar parameters. You can specify on what schedule your function should be called. When your function is called, it will not receive any arguments except self , but you can of course call any MachineBasePlugin methods to send message and do other things. Example: @schedule ( hour = \"9-17\" , minute = \"*/30\" ) async def movement_reminder ( self ): await self . say ( \"general\" , \"<!here> maybe now is a good time to take a short walk!\" ) Events Slack Machine can respond to events that are emitted by your plugin(s) or plugins of others, or events generated by parts of Slack Machine itself. You can use the @on decorator on a function to run that function whenever a certain event is emitted somewhere. Example: @on ( \"bathroom_used\" ) async def call_cleaning_department ( self , ** kwargs ): await self . say ( \"cleaning-department\" , \"<!here> Somebody used the toilet!\" ) This function will be called whenever the bathroom_used event is emitted somewhere. Some things to be aware of Event names are global, every plugin can emit and listen for the same events. This is by design, because this way, you can use events to exchange data between plugins. Events can be a way to expose a \"public API\" for plugins. But this can also mean your functions are unexpectedly triggered by events sent by other plugins, especially if the event names you choose are very generic. When emitting events, plugins can attach whatever variables they want to the event, and when listening for an event, your function will be called with whatever arguments were attached to the event when the event was emitted. It's therefor a good idea to always include **kwargs as a catch-all, otherwise your function could return an error when it's called with arguments that have not been explicitly defined. So what is this event system useful for? As mentioned in the above note, events can be used to communicate between plugins and/or for plugins to respond to events that happen within the core of Slack Machine. A good example of this, is the unauthorized-access event. This event will be emitted whenever someone tries to use a bot command protected by the require_any_role or require_all_roles decorators without having the right roles to issue that command. By listening to this event, your plugins can take action when this happens. The built-in RBAC plugin also listens for this event. You can read emitting events to learn how to emit events from your own plugins.","title":"Listening for things"},{"location":"plugins/listening/#listening-for-things","text":"Slack Machine allows you to listen for various different things and respond to that. By decorating functions in your plugin using the decorators Slack Machine provides, you can tell Slack Machine to run those functions when something specific happens.","title":"Listening for things"},{"location":"plugins/listening/#listen-for-a-mention","text":"The respond_to decorator tells Slack Machine to listen for messages mentioning your bot and matching a specific pattern. Slack Machine will hear messages sent in any channel or private group it is a member of. For a message to trigger a function decorated by @respond_to(...) , the message has to start with a mention of your bot or with any alias the user configured using the ALIASES setting. The exception is direct messages sent to the bot, they don't have to include a mention to trigger @respond_to . @respond_to takes 3 parameters: regex ( required ): the regular expression Slack Machine should listen for. The regex pattern should not account for the mention of your bot, as Slack Machine will remove the mention before looking for a match. Slack Machine listens for any occurrence of the pattern in the message, so if you want to specifically match the whole message, you can anchor your pattern using the ^ and $ symbols. flags (optional): can be used to pass flags for the regex matching as defined in the re module. By default, re.IGNORECASE is applied. handle_message_changed (optional): is used to configure if Slack Machine should trigger this function for messages that have been changed . By default, only new messages will trigger the decorated function.","title":"Listen for a mention"},{"location":"plugins/listening/#how-your-function-will-be-called","text":"Your function will be called with a Message object that represents the message that triggered the function. It not only contains the message text itself, but also has many convenient methods for replying. Example: @respond_to ( r \"^I love you\" ) async def spread_love ( self , msg ): await msg . reply ( \"I love you too!\" ) The regex pattern can optionally contain named groups that will be captured and passed to your function as keyword arguments. Example: @respond_to ( r \"You deserve (?P<num_stars>\\d+) stars!\" ) async def award ( self , msg , num_stars ): stars_back = int ( num_stars ) + 1 await msg . reply ( \"Well, you deserve {} !\" . format ( stars_back ))","title":"How your function will be called"},{"location":"plugins/listening/#hear-any-message","text":"The @listen_to decorator works similar as the @respond_to decorator, but it will hear any message matching a pattern, without the bot being explicitly mentioned. @listen_to takes the same parameters as @respond_to . Example: @listen_to ( r \"go for it\" ) @listen_to ( r \"go 4 it\" ) async def go_for_it ( self , msg ): await msg . say ( \"https://a-z-animals.com/media/animals/images/original/gopher_2.jpg\" ) As you can see, you can also apply the same decorator multiple times to a function, each time with different arguments. Of course, you can also combine different decorators on one function.","title":"Hear any message"},{"location":"plugins/listening/#more-flexibility-with-slack-events","text":"If you want your bot to respond to other things than messages, you can do so using the @process decorator. @process requires an event_type as parameter and will trigger the decorated function any time an event of the specified type happens. It can listen to any Slack event that is supported by the Events API. The received event will be passed to your function. The following example will listen for the reaction_added event to know if a reaction was added to a message, and will match that reaction: @process ( \"reaction_added\" ) async def match_reaction ( self , event ): emoji = event [ \"reaction\" ] channel = event [ \"item\" ][ \"channel\" ] ts = event [ \"item\" ][ \"ts\" ] await self . react ( channel , ts , emoji ) As you can see, @process gives you a lot of flexibility by allowing you to process any event Slack Machine does not provide a specific decorator for.","title":"More flexibility with Slack events"},{"location":"plugins/listening/#take-action-on-a-schedule","text":"Slack Machine can also run functions on a schedule, using the @schedule decorator. @schedule behaves like Linux/Unix Crontab , and receives similar parameters. You can specify on what schedule your function should be called. When your function is called, it will not receive any arguments except self , but you can of course call any MachineBasePlugin methods to send message and do other things. Example: @schedule ( hour = \"9-17\" , minute = \"*/30\" ) async def movement_reminder ( self ): await self . say ( \"general\" , \"<!here> maybe now is a good time to take a short walk!\" )","title":"Take action on a Schedule"},{"location":"plugins/listening/#events","text":"Slack Machine can respond to events that are emitted by your plugin(s) or plugins of others, or events generated by parts of Slack Machine itself. You can use the @on decorator on a function to run that function whenever a certain event is emitted somewhere. Example: @on ( \"bathroom_used\" ) async def call_cleaning_department ( self , ** kwargs ): await self . say ( \"cleaning-department\" , \"<!here> Somebody used the toilet!\" ) This function will be called whenever the bathroom_used event is emitted somewhere. Some things to be aware of Event names are global, every plugin can emit and listen for the same events. This is by design, because this way, you can use events to exchange data between plugins. Events can be a way to expose a \"public API\" for plugins. But this can also mean your functions are unexpectedly triggered by events sent by other plugins, especially if the event names you choose are very generic. When emitting events, plugins can attach whatever variables they want to the event, and when listening for an event, your function will be called with whatever arguments were attached to the event when the event was emitted. It's therefor a good idea to always include **kwargs as a catch-all, otherwise your function could return an error when it's called with arguments that have not been explicitly defined. So what is this event system useful for? As mentioned in the above note, events can be used to communicate between plugins and/or for plugins to respond to events that happen within the core of Slack Machine. A good example of this, is the unauthorized-access event. This event will be emitted whenever someone tries to use a bot command protected by the require_any_role or require_all_roles decorators without having the right roles to issue that command. By listening to this event, your plugins can take action when this happens. The built-in RBAC plugin also listens for this event. You can read emitting events to learn how to emit events from your own plugins.","title":"Events"},{"location":"plugins/misc/","text":"Miscellaneous stuff This section contains some odds and ends that were not discussed in previous sections. Plugin initialization Plugins are initialized when Slack Machine starts. Because the MachineBasePlugin already has a constructor that is used to pass various things to the plugin instance at startup, it is advised not to provide a constructor for your plugin. If your plugin needs to initialize its own things at startup, you can override the init() method. This method will be called once when the plugin is initialized. It is no-op by default. Logging Slack Machine uses structlog for logging. In your plugins, you can instantiate and use a logger as follows: from structlog.stdlib import get_logger logger = get_logger ( __name__ ) async def my_function (): logger . info ( \"Running my function\" , foo = 42 , bar = \"hello\" ) Logging message handler invocations By default, Slack Machine will log anytime a Slack message triggers a handler in a plugin. This log statement will include the message that triggered the handler and the user id & name of the user that posted the message. You can disable these log message by setting LOG_HANDLED_MESSAGES to False in your local_settings.py Using loggers provided by Slack Machine in your handler functions Structlog allows adding extra parameters as context. Slack Machine leverages this to bind the id and name of the user who sent a message to a logger as context variables whenever a message triggers a handler function. You can opt-in to using this logger, by adding a logger parameter to your handler function. async def my_handler ( msg , logger ): logger . info ( \"my_handler invoked!\" ) Slack Machine will automatically inject a logger with the right context variables into your handler. The example will produce a message like: 2022 -10-21T14:29:05.639162Z [ info ] my_handler invoked! [ example_plugin.my_plugin:MyPlugin.my_handler ] filename = my_plugin.py func_name = my_handler lineno = 5 user_id = U12345678 user_name = user1 This works only for handler functions that are decorated with respond_to or listen_to Plugin help information You can provide help text for your plugin and its commands by adding docstrings to your plugin class and its methods. The first line of the docstring of a plugin class will be used for grouping help information of plugin methods. This even extends beyond one class, ie. if multiple plugin classes have the same docstring (first line), the help information for the methods under those classes will be grouped together. The first line of the docstring of each plugin method can be used for specifying help information for that specific function. It should be in the format command: help text . The machine.plugins.builtin.help.HelpPlugin (enabled by default) will provide Slack users with the help information described above.","title":"Miscellaneous stuff"},{"location":"plugins/misc/#miscellaneous-stuff","text":"This section contains some odds and ends that were not discussed in previous sections.","title":"Miscellaneous stuff"},{"location":"plugins/misc/#plugin-initialization","text":"Plugins are initialized when Slack Machine starts. Because the MachineBasePlugin already has a constructor that is used to pass various things to the plugin instance at startup, it is advised not to provide a constructor for your plugin. If your plugin needs to initialize its own things at startup, you can override the init() method. This method will be called once when the plugin is initialized. It is no-op by default.","title":"Plugin initialization"},{"location":"plugins/misc/#logging","text":"Slack Machine uses structlog for logging. In your plugins, you can instantiate and use a logger as follows: from structlog.stdlib import get_logger logger = get_logger ( __name__ ) async def my_function (): logger . info ( \"Running my function\" , foo = 42 , bar = \"hello\" )","title":"Logging"},{"location":"plugins/misc/#logging-message-handler-invocations","text":"By default, Slack Machine will log anytime a Slack message triggers a handler in a plugin. This log statement will include the message that triggered the handler and the user id & name of the user that posted the message. You can disable these log message by setting LOG_HANDLED_MESSAGES to False in your local_settings.py","title":"Logging message handler invocations"},{"location":"plugins/misc/#using-loggers-provided-by-slack-machine-in-your-handler-functions","text":"Structlog allows adding extra parameters as context. Slack Machine leverages this to bind the id and name of the user who sent a message to a logger as context variables whenever a message triggers a handler function. You can opt-in to using this logger, by adding a logger parameter to your handler function. async def my_handler ( msg , logger ): logger . info ( \"my_handler invoked!\" ) Slack Machine will automatically inject a logger with the right context variables into your handler. The example will produce a message like: 2022 -10-21T14:29:05.639162Z [ info ] my_handler invoked! [ example_plugin.my_plugin:MyPlugin.my_handler ] filename = my_plugin.py func_name = my_handler lineno = 5 user_id = U12345678 user_name = user1 This works only for handler functions that are decorated with respond_to or listen_to","title":"Using loggers provided by Slack Machine in your handler functions"},{"location":"plugins/misc/#plugin-help-information","text":"You can provide help text for your plugin and its commands by adding docstrings to your plugin class and its methods. The first line of the docstring of a plugin class will be used for grouping help information of plugin methods. This even extends beyond one class, ie. if multiple plugin classes have the same docstring (first line), the help information for the methods under those classes will be grouped together. The first line of the docstring of each plugin method can be used for specifying help information for that specific function. It should be in the format command: help text . The machine.plugins.builtin.help.HelpPlugin (enabled by default) will provide Slack users with the help information described above.","title":"Plugin help information"},{"location":"plugins/settings/","text":"Plugin Settings All settings that are defined, either from the Slack Machine defaults or in local_settings.py are available to plugins through the self.settings field. This is a dictionary with all settings indexed by their name. Next to local_settings.py , users can also specify settings with environment variables. Slack Machine will automatically translate any environment variable with the format SM_<SETTING_NAME> to a setting with name SETTING_NAME , overriding a setting with the same name from local_settings.py or the default settings. So an environment variable SM_SLACK_APP_TOKEN will result in a setting SLACK_APP_TOKEN . Setting names are case insensitive . Example of using settings When the local_settings.py looks like this: SLACK_APP_TOKEN = \"xapp-my-app-token\" SLACK_BOT_TOKEN = \"xoxb-my-bot-token\" GREETING_PLUGIN_MY_GREETING = \"Bonjour\" This can be used in a plugin, like this: @respond_to ( r \"Hello!\" ) async def greeting ( self , msg ): await msg . reply ( f \" { self . settings [ 'GREETING_PLUGIN_MY_GREETING' ] } , { msg . at_sender } !\" ) The response to a message @superbot Hello! from @john , in this case would be: Bonjour, @john! Required settings If your plugin requires one or more settings to be defined in order to work, you can mark them as required with the @required_settings decorator. This decorator takes a string or a list of strings as argument which can be one or more settings that are required by your plugin. Upon startup, Slack Machine will check if any of the settings that are marked as required by a plugin, have not been defined by the user. If it finds one or more missing settings, it will not load that particular plugin, and notify the user which settings are missing. The @required_settings decorator can be applied to a plugin class and/or its methods. Note that if any of the required settings are missing, the plugin will not load as a whole, so none of the methods will be registered. Example: @required_settings ([ \"TODO_SERVICE_USERNAME\" , \"TODO_SERVICE_PASSWORD\" ]) class TodoPlugin ( MachineBasePlugin ): ...","title":"Plugin Settings"},{"location":"plugins/settings/#plugin-settings","text":"All settings that are defined, either from the Slack Machine defaults or in local_settings.py are available to plugins through the self.settings field. This is a dictionary with all settings indexed by their name. Next to local_settings.py , users can also specify settings with environment variables. Slack Machine will automatically translate any environment variable with the format SM_<SETTING_NAME> to a setting with name SETTING_NAME , overriding a setting with the same name from local_settings.py or the default settings. So an environment variable SM_SLACK_APP_TOKEN will result in a setting SLACK_APP_TOKEN . Setting names are case insensitive .","title":"Plugin Settings"},{"location":"plugins/settings/#example-of-using-settings","text":"When the local_settings.py looks like this: SLACK_APP_TOKEN = \"xapp-my-app-token\" SLACK_BOT_TOKEN = \"xoxb-my-bot-token\" GREETING_PLUGIN_MY_GREETING = \"Bonjour\" This can be used in a plugin, like this: @respond_to ( r \"Hello!\" ) async def greeting ( self , msg ): await msg . reply ( f \" { self . settings [ 'GREETING_PLUGIN_MY_GREETING' ] } , { msg . at_sender } !\" ) The response to a message @superbot Hello! from @john , in this case would be: Bonjour, @john!","title":"Example of using settings"},{"location":"plugins/settings/#required-settings","text":"If your plugin requires one or more settings to be defined in order to work, you can mark them as required with the @required_settings decorator. This decorator takes a string or a list of strings as argument which can be one or more settings that are required by your plugin. Upon startup, Slack Machine will check if any of the settings that are marked as required by a plugin, have not been defined by the user. If it finds one or more missing settings, it will not load that particular plugin, and notify the user which settings are missing. The @required_settings decorator can be applied to a plugin class and/or its methods. Note that if any of the required settings are missing, the plugin will not load as a whole, so none of the methods will be registered. Example: @required_settings ([ \"TODO_SERVICE_USERNAME\" , \"TODO_SERVICE_PASSWORD\" ]) class TodoPlugin ( MachineBasePlugin ): ...","title":"Required settings"},{"location":"plugins/storage/","text":"Storage Slack Machine provides persistent storage that can easily be accessed from plugins through self.storage . This field contains an instance of PluginStorage , which lets you store, retrieve and remove values by key, check for the existence of a key and get information about the current size of the underlying storage. The PluginStorage class interfaces with whatever storage backend Slack Machine is configured with. You can read more about the available storage backends in the user guide . Example: @respond_to ( r \"store (?P<text>.*) under (?P<key>\\w+)\" ) async def store ( self , msg , text , key ): await self . storage . set ( key , text ) await msg . say ( f \"' { text } ' stored under { key } !\" ) @respond_to ( r \"retrieve (?P<key>\\w+)\" ) async def retrieve ( self , msg , key ): data = await self . storage . get ( key ) if data : await msg . say ( f \"' { data } ' retrieved from < { key } >!\" ) else : await msg . say ( \"Key not found!\" ) @respond_to ( r \"delete (?P<key>\\w+)\" ) async def delete ( self , msg , key ): await self . storage . delete ( key ) await msg . say ( f \"data in < { key } > deleted!\" ) @respond_to ( r \"does (?P<key>\\w+) exist?\" ) async def exists ( self , msg , key ): if await self . storage . has ( key ): await msg . say ( f \"< { key } > exists.\" ) else : await msg . say ( f \"< { key } > does not exist!\" ) @respond_to ( r \"size\" ) async def size ( self , msg ): human_size = await self . storage . get_storage_size_human () await msg . say ( \"storage size: {human_size} \" ) Shared vs non-shared By default, when you store, retrieve and remove data by key, Slack Machine will automatically namespace the keys you use with the fully qualified classname of the plugin the storage is used from. This is done to prevent plugins from changing or even deleting each others data. So when you do this: # resides in module my.plugin.package class MyPlugin : async def some_function (): await self . storage . set ( \"my-key\" , \"my-data\" ) Slack Machine will send the key my.plugin.package.MyPlugin:my-key to the storage backend. You can override this behaviour by setting the shared parameter to True when calling a storage related function that requires a key as parameter. This keep the key global (ie. non-namespaced). This is useful when you want to share data between plugins. Use this feature with care though, as you can destroy data that belongs to other plugins! Implementing your own storage backend You can implement your own storage backend by subclassing [ MachineBaseStorage ][machine.storage.backends.base. MachineBaseStorage]. You only have to implement a couple of methods, and you don't have to take care of namespacing of keys, as Slack Machine will do that for you.","title":"Storage"},{"location":"plugins/storage/#storage","text":"Slack Machine provides persistent storage that can easily be accessed from plugins through self.storage . This field contains an instance of PluginStorage , which lets you store, retrieve and remove values by key, check for the existence of a key and get information about the current size of the underlying storage. The PluginStorage class interfaces with whatever storage backend Slack Machine is configured with. You can read more about the available storage backends in the user guide . Example: @respond_to ( r \"store (?P<text>.*) under (?P<key>\\w+)\" ) async def store ( self , msg , text , key ): await self . storage . set ( key , text ) await msg . say ( f \"' { text } ' stored under { key } !\" ) @respond_to ( r \"retrieve (?P<key>\\w+)\" ) async def retrieve ( self , msg , key ): data = await self . storage . get ( key ) if data : await msg . say ( f \"' { data } ' retrieved from < { key } >!\" ) else : await msg . say ( \"Key not found!\" ) @respond_to ( r \"delete (?P<key>\\w+)\" ) async def delete ( self , msg , key ): await self . storage . delete ( key ) await msg . say ( f \"data in < { key } > deleted!\" ) @respond_to ( r \"does (?P<key>\\w+) exist?\" ) async def exists ( self , msg , key ): if await self . storage . has ( key ): await msg . say ( f \"< { key } > exists.\" ) else : await msg . say ( f \"< { key } > does not exist!\" ) @respond_to ( r \"size\" ) async def size ( self , msg ): human_size = await self . storage . get_storage_size_human () await msg . say ( \"storage size: {human_size} \" )","title":"Storage"},{"location":"plugins/storage/#shared-vs-non-shared","text":"By default, when you store, retrieve and remove data by key, Slack Machine will automatically namespace the keys you use with the fully qualified classname of the plugin the storage is used from. This is done to prevent plugins from changing or even deleting each others data. So when you do this: # resides in module my.plugin.package class MyPlugin : async def some_function (): await self . storage . set ( \"my-key\" , \"my-data\" ) Slack Machine will send the key my.plugin.package.MyPlugin:my-key to the storage backend. You can override this behaviour by setting the shared parameter to True when calling a storage related function that requires a key as parameter. This keep the key global (ie. non-namespaced). This is useful when you want to share data between plugins. Use this feature with care though, as you can destroy data that belongs to other plugins!","title":"Shared vs non-shared"},{"location":"plugins/storage/#implementing-your-own-storage-backend","text":"You can implement your own storage backend by subclassing [ MachineBaseStorage ][machine.storage.backends.base. MachineBaseStorage]. You only have to implement a couple of methods, and you don't have to take care of namespacing of keys, as Slack Machine will do that for you.","title":"Implementing your own storage backend"},{"location":"user/install/","text":"Installation This part of the documentation helps you install Slack Machine with the least amount of friction, or the most amount of flexibility. Installing the easy way with pip Slack Machine is published to the Python package index so you can easily install Slack Machine using pip: pip install slack-machine or add it to your Poetry project: poetry add slack-machine It is strongly recommended that you install slack-machine inside a virtual environment ! Installing from source If you are adventurous, want to modify the core of your Slack Machine instance and want maximum flexibility, you can also install from source. This way, you can enjoy the latest and greatest! You can either clone the public repository: git clone git://github.com/DonDebonair/slack-machine.git Or, download the tarball : curl -OL https://github.com/DonDebonair/slack-machine/tarball/main Optionally, zipball is also available (for Windows users). Once you have a copy of the source, you can embed it in your own Python package, or install it into your virtualenv easily: cd slack-machine pip install .","title":"Installation"},{"location":"user/install/#installation","text":"This part of the documentation helps you install Slack Machine with the least amount of friction, or the most amount of flexibility.","title":"Installation"},{"location":"user/install/#installing-the-easy-way-with-pip","text":"Slack Machine is published to the Python package index so you can easily install Slack Machine using pip: pip install slack-machine or add it to your Poetry project: poetry add slack-machine It is strongly recommended that you install slack-machine inside a virtual environment !","title":"Installing the easy way with pip"},{"location":"user/install/#installing-from-source","text":"If you are adventurous, want to modify the core of your Slack Machine instance and want maximum flexibility, you can also install from source. This way, you can enjoy the latest and greatest! You can either clone the public repository: git clone git://github.com/DonDebonair/slack-machine.git Or, download the tarball : curl -OL https://github.com/DonDebonair/slack-machine/tarball/main Optionally, zipball is also available (for Windows users). Once you have a copy of the source, you can embed it in your own Python package, or install it into your virtualenv easily: cd slack-machine pip install .","title":"Installing from source"},{"location":"user/intro/","text":"Introduction Philosophy Slack Machine is a simple, yet powerful and extendable bot framework & platform for Slack. Slack Machine should be: Full-featured Easy to extend Easy to contribute to (the core) Fun to use Fun to extend My dream would be, that a community springs up around Slack Machine, that produces a myriad of useful plugins that are easy to install and use. Non-goals These are non-goals for me at the moment, but that might change in the future: Support for other backends than Slack Built-in AI. At least not in the core, although whatever intelligence developers put into their plugins, is cool of course Why Slack Machine was built I love Slack, and I use it on a daily basis, both at work and in my private life. Due to the powerful APIs that Slack exposes, it's not only great for chatting, but also for automation. We developers love automation, so I wanted to add some of that to the Slack workspaces I'm a member of. Obviously, there have already been many attempts to leverage this extensibility of Slack, considering the many apps/bots/bot frameworks/chatops frameworks out there. Why build another one?! All of the options that I could find, were inadequate for some reason. I've used Hubot a lot in the past, but Coffeescript (or Javascript for that matter), just doesn't click with me. I personally feel that Python is a great language to tackle this sort of problem, so I started looking for Slack bots written in Python. At the time I created Slack Machine, these were the options I could find: python-rtmbot : Created by the Slack team, this bot is very barebones and exposes a very low-level plugin API. This makes it hard/tedious to write plugins for it. It is not mainainted anymore slackbot : Has a more high-level plugin API, which is built on the right ideas in terms of developer friendlyness. But it was lacking some features that I want in a bot (among other things: scheduling, persistent storage and a help-feature), and I found that the plugin architecture didn't allow for proper plugin organisation. This made me decide not to contribute, and instead start my own project. Will : This was originally not a bot for Slack, but for Hipchat, but it has support for Slack (and other backends) since a couple of years. I'm including it. Will came closests to what I want, both in terms of feature set and plugin API. At the time I created Slack Machine, it only supported HipChat and I personally found the code quite hard to read. I also feel that a framework supporting many different chat platforms is bound to serve the lowest common denominator. This will lead to suboptimal quality. So, in the end I decided that writing a full-featured, easy-to-extend Slack bot, written in Python, would be cool new project to take up. Note The above was written 4 years ago and a lot has changed since then. The Slack team has created Bolt , a bot framework that is quite similar to Slack Machine. There are still differences in the way code is organized and I feel that Slack Machine is better suited to build complex Slack bots with in which code is organized in multiple plugins. This is currently not supported by Bolt I plan to keep maintaining Slack Machine and bringing it up to date with current best practices, so that the features and developer experience are on-par with or better than Bolt Acknowledgements Slack Machine owes a great deal of debt to the aforementioned packages. Parts of the API of Slack Machine were inspired by those packages, and I was at a great advantage while building Slack Machine because I was able to look at existing code to get an idea on how to approach certain problems. While obviously I'd like to think I have improved upon my inspirations, Slack Machine couldn't have existed without them. Slack Machine License MIT License Copyright (c) 2018 Daan Debie Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Introduction"},{"location":"user/intro/#introduction","text":"","title":"Introduction"},{"location":"user/intro/#philosophy","text":"Slack Machine is a simple, yet powerful and extendable bot framework & platform for Slack. Slack Machine should be: Full-featured Easy to extend Easy to contribute to (the core) Fun to use Fun to extend My dream would be, that a community springs up around Slack Machine, that produces a myriad of useful plugins that are easy to install and use.","title":"Philosophy"},{"location":"user/intro/#non-goals","text":"These are non-goals for me at the moment, but that might change in the future: Support for other backends than Slack Built-in AI. At least not in the core, although whatever intelligence developers put into their plugins, is cool of course","title":"Non-goals"},{"location":"user/intro/#why-slack-machine-was-built","text":"I love Slack, and I use it on a daily basis, both at work and in my private life. Due to the powerful APIs that Slack exposes, it's not only great for chatting, but also for automation. We developers love automation, so I wanted to add some of that to the Slack workspaces I'm a member of. Obviously, there have already been many attempts to leverage this extensibility of Slack, considering the many apps/bots/bot frameworks/chatops frameworks out there. Why build another one?! All of the options that I could find, were inadequate for some reason. I've used Hubot a lot in the past, but Coffeescript (or Javascript for that matter), just doesn't click with me. I personally feel that Python is a great language to tackle this sort of problem, so I started looking for Slack bots written in Python. At the time I created Slack Machine, these were the options I could find: python-rtmbot : Created by the Slack team, this bot is very barebones and exposes a very low-level plugin API. This makes it hard/tedious to write plugins for it. It is not mainainted anymore slackbot : Has a more high-level plugin API, which is built on the right ideas in terms of developer friendlyness. But it was lacking some features that I want in a bot (among other things: scheduling, persistent storage and a help-feature), and I found that the plugin architecture didn't allow for proper plugin organisation. This made me decide not to contribute, and instead start my own project. Will : This was originally not a bot for Slack, but for Hipchat, but it has support for Slack (and other backends) since a couple of years. I'm including it. Will came closests to what I want, both in terms of feature set and plugin API. At the time I created Slack Machine, it only supported HipChat and I personally found the code quite hard to read. I also feel that a framework supporting many different chat platforms is bound to serve the lowest common denominator. This will lead to suboptimal quality. So, in the end I decided that writing a full-featured, easy-to-extend Slack bot, written in Python, would be cool new project to take up. Note The above was written 4 years ago and a lot has changed since then. The Slack team has created Bolt , a bot framework that is quite similar to Slack Machine. There are still differences in the way code is organized and I feel that Slack Machine is better suited to build complex Slack bots with in which code is organized in multiple plugins. This is currently not supported by Bolt I plan to keep maintaining Slack Machine and bringing it up to date with current best practices, so that the features and developer experience are on-par with or better than Bolt","title":"Why Slack Machine was built"},{"location":"user/intro/#acknowledgements","text":"Slack Machine owes a great deal of debt to the aforementioned packages. Parts of the API of Slack Machine were inspired by those packages, and I was at a great advantage while building Slack Machine because I was able to look at existing code to get an idea on how to approach certain problems. While obviously I'd like to think I have improved upon my inspirations, Slack Machine couldn't have existed without them.","title":"Acknowledgements"},{"location":"user/intro/#slack-machine-license","text":"MIT License Copyright (c) 2018 Daan Debie Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Slack Machine License"},{"location":"user/usage/","text":"Using Slack Machine Once you have installed Slack Machine, configuring and starting your bot is easy: Create a directory for your Slack Machine bot: mkdir my-slack-bot && cd my-slack-bot Add a local_settings.py file to your bot directory: touch local_settings.py Create a new app in Slack: https://api.slack.com/apps Choose to create an app from an App manifest Copy/paste the following manifest: manifest.yaml display_information: name: Slack Machine features: bot_user: display_name: Slack Machine always_online: false oauth_config: scopes: bot: - app_mentions:read - channels:history - channels:join - channels:read - chat:write - chat:write.public - emoji:read - groups:history - groups:read - groups:write - im:history - im:read - im:write - mpim:history - mpim:read - mpim:write - pins:read - pins:write - reactions:read - reactions:write - users:read - users:read.email - channels:manage - chat:write.customize - dnd:read - files:read - files:write - links:read - links:write - metadata.message:read - usergroups:read - usergroups:write - users.profile:read - users:write settings: event_subscriptions: bot_events: - app_mention - channel_archive - channel_created - channel_deleted - channel_id_changed - channel_left - channel_rename - channel_unarchive - group_archive - group_deleted - group_left - group_rename - group_unarchive - member_joined_channel - member_left_channel - message.channels - message.groups - message.im - message.mpim - reaction_added - reaction_removed - team_join - user_change - user_profile_changed - user_status_changed interactivity: is_enabled: true org_deploy_enabled: false socket_mode_enabled: true token_rotation_enabled: false Add the Slack App and Bot tokens to your local_settings.py like this: local_settings.py SLACK_APP_TOKEN = \"xapp-my-app-token\" SLACK_BOT_TOKEN = \"xoxb-my-bot-token\" Start the bot with slack-machine ... Profit! Configuring Slack Machine All the configuration for your bot lives in the local_settings.py in the root of your bot directory. The core of Slack Machine, and the most of the built-in plugins, only need a SLACK_APP_TOKEN and SLACK_BOT_TOKEN to function. You can override the log level by setting LOGLEVEL . By default this is set to \"ERROR\" . If you want to use Slack Machine behind a proxy, you can set HTTP_PROXY . Using environment variables for configuration For some configuration, it can be a security consideration not to store them in your source code (i.e. local_settings.py ) Slack Machine allows you to provide any setting - both built-in and for plugins - as environment variables. This is done by prefixing the setting name with SM_ . Example: SM_SLACK_APP_TOKEN and SM_SLACK_BOT_TOKEN as environment variable can be used to set the SLACK_APP_TOKEN and SLACK_BOT_TOKEN settings instead of having to put it in the local_settings.py . This way you can follow the 12 Factor app best practices to configure your bot! Setting aliases The ALIASES configuration setting allows the bot to respond to a trigger symbol instead of a direct @botname. Example: If ALIASES='!,%' was set in local_settings.py then the bot would respond to the following phrases: @botname release the hounds !release the hounds %release the hounds Enabling plugins Slack Machine comes with a few simple built-in plugins: HelloPlugin : responds in kind when users greet the bot with \"hello\" or \"hi\" (only when the bot is mentioned) PingPongPlugin : responds to \"ping\" with \"pong\" and vice versa (listens regardless of mention) EchoPlugin : replies to any message the bot hears, with exactly the same message. The bot will reply to the same channel the original message was heard in HelpPlugin : responds to \"help\" with a list of all available commands and how they work. You can use \"robot help\" to learn the regexes that are used to match commands. MemePlugin : lets the user generate memes based on templates and captions Uses Memegen ImageSearchPlugin : lets users search images and gifs using Google Custom Search (requires setting up a Programmable Search Engine in Google and adding the search engine id as GOOGLE_CSE_ID and a Google API key as GOOGLE_API_KEY ) RBACPlugin : lets admins assign, revoke and list user roles. Is used when you want to protect commands By default, HelloPlugin and PingPongPlugin are enabled. You can specify which plugins Slack Machine should load, by setting the PLUGINS variable in local_settings.py to a list of fully qualified classes or modules that contain plugins. You can either point to a plugin class directly, or to a module containing one or more plugins. For example, to enable most of the built-in Slack Machine plugins, your local_settings.py would look like this: SLACK_APP_TOKEN = \"xapp-my-app-token\" SLACK_BOT_TOKEN = \"xoxb-my-bot-token\" PLUGINS = [ \"machine.plugins.builtin.general.PingPongPlugin\" , \"machine.plugins.builtin.general.HelloPlugin\" , \"machine.plugins.builtin.debug.EchoPlugin\" , \"machine.plugins.builtin.fun.memes.MemePlugin\" , \"machine.plugins.builtin.help.HelpPlugin\" , ] Or is you want import them by the modules they're in: SLACK_APP_TOKEN = \"xapp-my-app-token\" SLACK_BOT_TOKEN = \"xoxb-my-bot-token\" PLUGINS = [ \"machine.plugins.builtin.general\" , \"machine.plugins.builtin.debug\" , \"machine.plugins.builtin.help\" , \"machine.plugins.builtin.fun.memes\" , ] Slack Machine can load any plugin that is on the Python path. This means you can load any plugin that is installed in the same virtual environment you installed Slack Machine in. And as a convenience, Slack Machine will also add the directory you start Slack Machine from, to your Python path. Choosing storage Slack Machine provides persistent storage, which can be used by plugins to store data of any kind. Slack Machine supports different backends for storage, so you can choose one that best fits your needs and existing infrastructure. You can configure which backend to use, by setting the STORAGE_BACKEND variable in local_settings.py to the fully qualified class of the chosen storage backend. Out of the box, Slack Machine provides 3 options for storage backend: in-memory ( default ): This backend will store all data in-memory, which is great for testing because it doesn't have any external dependencies. Does not persist data between restarts Class : machine.storage.backends.memory.MemoryStorage Redis: This backend stores data in Redis . Redis is a very fast key-value store that is super easy to install and operate. This backend is recommended, because it will persist data between restarts. The Redis backend requires you to provide a URL to your Redis instance by setting the REDIS_URL variable in local_settings.py . The URL should have the following format: `redis://<host>:<port>[/<db>]` Where db is optional and sets the database number ( 0 by default) Optional parameters: REDIS_MAX_CONNECTIONS : maximum number of connections Slack Machine can make to your Redis instance REDIS_KEY_PREFIX : the prefix Slack Machine uses for keys ( SM by default, so \"key1\" gets stored under SM:key1 ) Class : machine.storage.backends.redis.RedisStorage DynamoDB This backend stores data in DynamoDB . DynamoDB is a managed NoSQL datastore on AWS that, among other things, allows for easy persistance of objects by key. The DynamoDB backend requires either a set of valid AWS account credentials, or a locally running DynamoDB test bed, such as the one included in localstack . This backend requires the environment variables or path-based AWS credentials that are normally used to access AWS services. The following are optional parameters that can be set in your local_settings.py or SM_ environment variable slack-machine settings: Optional parameters: DYNAMODB_ENDPOINT_URL : specifies an optional alternate endpoint, for local bot testing DYNAMODB_KEY_PREFIX : an optional prefix to use within the key lookup. Defaults to SM: DYNAMODB_TABLE_NAME : specifies the table to use in DynamoDB. Defaults to slack-machine-state DYNAMODB_CREATE_TABLE : optionally -create- the table to be used in DynamoDB. Defaults to False DYNAMODB_CLIENT : if custom configuration is needed for the DynamoDB client, an optional aioboto3 resource can be specified here Class : machine.storage.backends.dynamodb.DynamoDBStorage So if, for example, you want to configure Slack Machine to use Redis as a storage backend, with your Redis instance running on localhost on the default port, you would add this to your local_settings.py : STORAGE_BACKEND = 'machine.storage.backends.redis.RedisStorage' REDIS_URL = redis : // localhost : 6379 ' That's all there is to it!","title":"Using Slack Machine"},{"location":"user/usage/#using-slack-machine","text":"Once you have installed Slack Machine, configuring and starting your bot is easy: Create a directory for your Slack Machine bot: mkdir my-slack-bot && cd my-slack-bot Add a local_settings.py file to your bot directory: touch local_settings.py Create a new app in Slack: https://api.slack.com/apps Choose to create an app from an App manifest Copy/paste the following manifest: manifest.yaml display_information: name: Slack Machine features: bot_user: display_name: Slack Machine always_online: false oauth_config: scopes: bot: - app_mentions:read - channels:history - channels:join - channels:read - chat:write - chat:write.public - emoji:read - groups:history - groups:read - groups:write - im:history - im:read - im:write - mpim:history - mpim:read - mpim:write - pins:read - pins:write - reactions:read - reactions:write - users:read - users:read.email - channels:manage - chat:write.customize - dnd:read - files:read - files:write - links:read - links:write - metadata.message:read - usergroups:read - usergroups:write - users.profile:read - users:write settings: event_subscriptions: bot_events: - app_mention - channel_archive - channel_created - channel_deleted - channel_id_changed - channel_left - channel_rename - channel_unarchive - group_archive - group_deleted - group_left - group_rename - group_unarchive - member_joined_channel - member_left_channel - message.channels - message.groups - message.im - message.mpim - reaction_added - reaction_removed - team_join - user_change - user_profile_changed - user_status_changed interactivity: is_enabled: true org_deploy_enabled: false socket_mode_enabled: true token_rotation_enabled: false Add the Slack App and Bot tokens to your local_settings.py like this: local_settings.py SLACK_APP_TOKEN = \"xapp-my-app-token\" SLACK_BOT_TOKEN = \"xoxb-my-bot-token\" Start the bot with slack-machine ... Profit!","title":"Using Slack Machine"},{"location":"user/usage/#configuring-slack-machine","text":"All the configuration for your bot lives in the local_settings.py in the root of your bot directory. The core of Slack Machine, and the most of the built-in plugins, only need a SLACK_APP_TOKEN and SLACK_BOT_TOKEN to function. You can override the log level by setting LOGLEVEL . By default this is set to \"ERROR\" . If you want to use Slack Machine behind a proxy, you can set HTTP_PROXY .","title":"Configuring Slack Machine"},{"location":"user/usage/#using-environment-variables-for-configuration","text":"For some configuration, it can be a security consideration not to store them in your source code (i.e. local_settings.py ) Slack Machine allows you to provide any setting - both built-in and for plugins - as environment variables. This is done by prefixing the setting name with SM_ . Example: SM_SLACK_APP_TOKEN and SM_SLACK_BOT_TOKEN as environment variable can be used to set the SLACK_APP_TOKEN and SLACK_BOT_TOKEN settings instead of having to put it in the local_settings.py . This way you can follow the 12 Factor app best practices to configure your bot!","title":"Using environment variables for configuration"},{"location":"user/usage/#setting-aliases","text":"The ALIASES configuration setting allows the bot to respond to a trigger symbol instead of a direct @botname. Example: If ALIASES='!,%' was set in local_settings.py then the bot would respond to the following phrases: @botname release the hounds !release the hounds %release the hounds","title":"Setting aliases"},{"location":"user/usage/#enabling-plugins","text":"Slack Machine comes with a few simple built-in plugins: HelloPlugin : responds in kind when users greet the bot with \"hello\" or \"hi\" (only when the bot is mentioned) PingPongPlugin : responds to \"ping\" with \"pong\" and vice versa (listens regardless of mention) EchoPlugin : replies to any message the bot hears, with exactly the same message. The bot will reply to the same channel the original message was heard in HelpPlugin : responds to \"help\" with a list of all available commands and how they work. You can use \"robot help\" to learn the regexes that are used to match commands. MemePlugin : lets the user generate memes based on templates and captions Uses Memegen ImageSearchPlugin : lets users search images and gifs using Google Custom Search (requires setting up a Programmable Search Engine in Google and adding the search engine id as GOOGLE_CSE_ID and a Google API key as GOOGLE_API_KEY ) RBACPlugin : lets admins assign, revoke and list user roles. Is used when you want to protect commands By default, HelloPlugin and PingPongPlugin are enabled. You can specify which plugins Slack Machine should load, by setting the PLUGINS variable in local_settings.py to a list of fully qualified classes or modules that contain plugins. You can either point to a plugin class directly, or to a module containing one or more plugins. For example, to enable most of the built-in Slack Machine plugins, your local_settings.py would look like this: SLACK_APP_TOKEN = \"xapp-my-app-token\" SLACK_BOT_TOKEN = \"xoxb-my-bot-token\" PLUGINS = [ \"machine.plugins.builtin.general.PingPongPlugin\" , \"machine.plugins.builtin.general.HelloPlugin\" , \"machine.plugins.builtin.debug.EchoPlugin\" , \"machine.plugins.builtin.fun.memes.MemePlugin\" , \"machine.plugins.builtin.help.HelpPlugin\" , ] Or is you want import them by the modules they're in: SLACK_APP_TOKEN = \"xapp-my-app-token\" SLACK_BOT_TOKEN = \"xoxb-my-bot-token\" PLUGINS = [ \"machine.plugins.builtin.general\" , \"machine.plugins.builtin.debug\" , \"machine.plugins.builtin.help\" , \"machine.plugins.builtin.fun.memes\" , ] Slack Machine can load any plugin that is on the Python path. This means you can load any plugin that is installed in the same virtual environment you installed Slack Machine in. And as a convenience, Slack Machine will also add the directory you start Slack Machine from, to your Python path.","title":"Enabling plugins"},{"location":"user/usage/#choosing-storage","text":"Slack Machine provides persistent storage, which can be used by plugins to store data of any kind. Slack Machine supports different backends for storage, so you can choose one that best fits your needs and existing infrastructure. You can configure which backend to use, by setting the STORAGE_BACKEND variable in local_settings.py to the fully qualified class of the chosen storage backend. Out of the box, Slack Machine provides 3 options for storage backend:","title":"Choosing storage"},{"location":"user/usage/#in-memory-default","text":"This backend will store all data in-memory, which is great for testing because it doesn't have any external dependencies. Does not persist data between restarts Class : machine.storage.backends.memory.MemoryStorage","title":"in-memory (default):"},{"location":"user/usage/#redis","text":"This backend stores data in Redis . Redis is a very fast key-value store that is super easy to install and operate. This backend is recommended, because it will persist data between restarts. The Redis backend requires you to provide a URL to your Redis instance by setting the REDIS_URL variable in local_settings.py . The URL should have the following format: `redis://<host>:<port>[/<db>]` Where db is optional and sets the database number ( 0 by default) Optional parameters: REDIS_MAX_CONNECTIONS : maximum number of connections Slack Machine can make to your Redis instance REDIS_KEY_PREFIX : the prefix Slack Machine uses for keys ( SM by default, so \"key1\" gets stored under SM:key1 ) Class : machine.storage.backends.redis.RedisStorage","title":"Redis:"},{"location":"user/usage/#dynamodb","text":"This backend stores data in DynamoDB . DynamoDB is a managed NoSQL datastore on AWS that, among other things, allows for easy persistance of objects by key. The DynamoDB backend requires either a set of valid AWS account credentials, or a locally running DynamoDB test bed, such as the one included in localstack . This backend requires the environment variables or path-based AWS credentials that are normally used to access AWS services. The following are optional parameters that can be set in your local_settings.py or SM_ environment variable slack-machine settings: Optional parameters: DYNAMODB_ENDPOINT_URL : specifies an optional alternate endpoint, for local bot testing DYNAMODB_KEY_PREFIX : an optional prefix to use within the key lookup. Defaults to SM: DYNAMODB_TABLE_NAME : specifies the table to use in DynamoDB. Defaults to slack-machine-state DYNAMODB_CREATE_TABLE : optionally -create- the table to be used in DynamoDB. Defaults to False DYNAMODB_CLIENT : if custom configuration is needed for the DynamoDB client, an optional aioboto3 resource can be specified here Class : machine.storage.backends.dynamodb.DynamoDBStorage So if, for example, you want to configure Slack Machine to use Redis as a storage backend, with your Redis instance running on localhost on the default port, you would add this to your local_settings.py : STORAGE_BACKEND = 'machine.storage.backends.redis.RedisStorage' REDIS_URL = redis : // localhost : 6379 ' That's all there is to it!","title":"DynamoDB"}]}